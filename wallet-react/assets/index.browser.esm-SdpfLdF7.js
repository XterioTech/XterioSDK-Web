var ra=Object.defineProperty;var sa=(r,e,t)=>e in r?ra(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var _e=(r,e,t)=>sa(r,typeof e!="symbol"?e+"":e,t);import{co as oa,cp as qr,cq as Hr,cr as ia,cs as aa,aB as Mr,ct as bo,aK as lt,cu as ca,aG as ve,cl as ua,aO as M,cv as _s}from"./index-GcZYKtlE.js";var vs,dr,hr=0,fr=0;function la(r,e,t){var n=e&&t||0,s=e||new Array(16);r=r||{};var o=r.node||vs,i=r.clockseq!==void 0?r.clockseq:dr;if(o==null||i==null){var a=r.random||(r.rng||oa)();o==null&&(o=vs=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=dr=(a[6]<<8|a[7])&16383)}var c=r.msecs!==void 0?r.msecs:Date.now(),u=r.nsecs!==void 0?r.nsecs:fr+1,l=c-hr+(u-fr)/1e4;if(l<0&&r.clockseq===void 0&&(i=i+1&16383),(l<0||c>hr)&&r.nsecs===void 0&&(u=0),u>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");hr=c,fr=u,dr=i,c+=122192928e5;var d=((c&268435455)*1e4+u)%4294967296;s[n++]=d>>>24&255,s[n++]=d>>>16&255,s[n++]=d>>>8&255,s[n++]=d&255;var p=c/4294967296*1e4&268435455;s[n++]=p>>>8&255,s[n++]=p&255,s[n++]=p>>>24&15|16,s[n++]=p>>>16&255,s[n++]=i>>>8|128,s[n++]=i&255;for(var f=0;f<6;++f)s[n+f]=o[f];return e||qr(s)}function mo(r){if(!Hr(r))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(r.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(r.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(r.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(r.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(r.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function da(r){r=unescape(encodeURIComponent(r));for(var e=[],t=0;t<r.length;++t)e.push(r.charCodeAt(t));return e}var ha="6ba7b810-9dad-11d1-80b4-00c04fd430c8",fa="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function wo(r,e,t){function n(s,o,i,a){if(typeof s=="string"&&(s=da(s)),typeof o=="string"&&(o=mo(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var u=0;u<16;++u)i[a+u]=c[u];return i}return qr(c)}try{n.name=r}catch{}return n.DNS=ha,n.URL=fa,n}function pa(r){if(typeof r=="string"){var e=unescape(encodeURIComponent(r));r=new Uint8Array(e.length);for(var t=0;t<e.length;++t)r[t]=e.charCodeAt(t)}return ga(ya(ba(r),r.length*8))}function ga(r){for(var e=[],t=r.length*32,n="0123456789abcdef",s=0;s<t;s+=8){var o=r[s>>5]>>>s%32&255,i=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);e.push(i)}return e}function ko(r){return(r+64>>>9<<4)+14+1}function ya(r,e){r[e>>5]|=128<<e%32,r[ko(e)-1]=e;for(var t=1732584193,n=-271733879,s=-1732584194,o=271733878,i=0;i<r.length;i+=16){var a=t,c=n,u=s,l=o;t=Ke(t,n,s,o,r[i],7,-680876936),o=Ke(o,t,n,s,r[i+1],12,-389564586),s=Ke(s,o,t,n,r[i+2],17,606105819),n=Ke(n,s,o,t,r[i+3],22,-1044525330),t=Ke(t,n,s,o,r[i+4],7,-176418897),o=Ke(o,t,n,s,r[i+5],12,1200080426),s=Ke(s,o,t,n,r[i+6],17,-1473231341),n=Ke(n,s,o,t,r[i+7],22,-45705983),t=Ke(t,n,s,o,r[i+8],7,1770035416),o=Ke(o,t,n,s,r[i+9],12,-1958414417),s=Ke(s,o,t,n,r[i+10],17,-42063),n=Ke(n,s,o,t,r[i+11],22,-1990404162),t=Ke(t,n,s,o,r[i+12],7,1804603682),o=Ke(o,t,n,s,r[i+13],12,-40341101),s=Ke(s,o,t,n,r[i+14],17,-1502002290),n=Ke(n,s,o,t,r[i+15],22,1236535329),t=We(t,n,s,o,r[i+1],5,-165796510),o=We(o,t,n,s,r[i+6],9,-1069501632),s=We(s,o,t,n,r[i+11],14,643717713),n=We(n,s,o,t,r[i],20,-373897302),t=We(t,n,s,o,r[i+5],5,-701558691),o=We(o,t,n,s,r[i+10],9,38016083),s=We(s,o,t,n,r[i+15],14,-660478335),n=We(n,s,o,t,r[i+4],20,-405537848),t=We(t,n,s,o,r[i+9],5,568446438),o=We(o,t,n,s,r[i+14],9,-1019803690),s=We(s,o,t,n,r[i+3],14,-187363961),n=We(n,s,o,t,r[i+8],20,1163531501),t=We(t,n,s,o,r[i+13],5,-1444681467),o=We(o,t,n,s,r[i+2],9,-51403784),s=We(s,o,t,n,r[i+7],14,1735328473),n=We(n,s,o,t,r[i+12],20,-1926607734),t=Fe(t,n,s,o,r[i+5],4,-378558),o=Fe(o,t,n,s,r[i+8],11,-2022574463),s=Fe(s,o,t,n,r[i+11],16,1839030562),n=Fe(n,s,o,t,r[i+14],23,-35309556),t=Fe(t,n,s,o,r[i+1],4,-1530992060),o=Fe(o,t,n,s,r[i+4],11,1272893353),s=Fe(s,o,t,n,r[i+7],16,-155497632),n=Fe(n,s,o,t,r[i+10],23,-1094730640),t=Fe(t,n,s,o,r[i+13],4,681279174),o=Fe(o,t,n,s,r[i],11,-358537222),s=Fe(s,o,t,n,r[i+3],16,-722521979),n=Fe(n,s,o,t,r[i+6],23,76029189),t=Fe(t,n,s,o,r[i+9],4,-640364487),o=Fe(o,t,n,s,r[i+12],11,-421815835),s=Fe(s,o,t,n,r[i+15],16,530742520),n=Fe(n,s,o,t,r[i+2],23,-995338651),t=De(t,n,s,o,r[i],6,-198630844),o=De(o,t,n,s,r[i+7],10,1126891415),s=De(s,o,t,n,r[i+14],15,-1416354905),n=De(n,s,o,t,r[i+5],21,-57434055),t=De(t,n,s,o,r[i+12],6,1700485571),o=De(o,t,n,s,r[i+3],10,-1894986606),s=De(s,o,t,n,r[i+10],15,-1051523),n=De(n,s,o,t,r[i+1],21,-2054922799),t=De(t,n,s,o,r[i+8],6,1873313359),o=De(o,t,n,s,r[i+15],10,-30611744),s=De(s,o,t,n,r[i+6],15,-1560198380),n=De(n,s,o,t,r[i+13],21,1309151649),t=De(t,n,s,o,r[i+4],6,-145523070),o=De(o,t,n,s,r[i+11],10,-1120210379),s=De(s,o,t,n,r[i+2],15,718787259),n=De(n,s,o,t,r[i+9],21,-343485551),t=Ot(t,a),n=Ot(n,c),s=Ot(s,u),o=Ot(o,l)}return[t,n,s,o]}function ba(r){if(r.length===0)return[];for(var e=r.length*8,t=new Uint32Array(ko(e)),n=0;n<e;n+=8)t[n>>5]|=(r[n/8]&255)<<n%32;return t}function Ot(r,e){var t=(r&65535)+(e&65535),n=(r>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function ma(r,e){return r<<e|r>>>32-e}function Zn(r,e,t,n,s,o){return Ot(ma(Ot(Ot(e,r),Ot(n,o)),s),t)}function Ke(r,e,t,n,s,o,i){return Zn(e&t|~e&n,r,e,s,o,i)}function We(r,e,t,n,s,o,i){return Zn(e&n|t&~n,r,e,s,o,i)}function Fe(r,e,t,n,s,o,i){return Zn(e^t^n,r,e,s,o,i)}function De(r,e,t,n,s,o,i){return Zn(t^(e|~n),r,e,s,o,i)}var wa=wo("v3",48,pa);function ka(r,e,t,n){switch(r){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function pr(r,e){return r<<e|r>>>32-e}function Sa(r){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof r=="string"){var n=unescape(encodeURIComponent(r));r=[];for(var s=0;s<n.length;++s)r.push(n.charCodeAt(s))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var o=r.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var u=new Uint32Array(16),l=0;l<16;++l)u[l]=r[c*64+l*4]<<24|r[c*64+l*4+1]<<16|r[c*64+l*4+2]<<8|r[c*64+l*4+3];a[c]=u}a[i-1][14]=(r.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(r.length-1)*8&4294967295;for(var d=0;d<i;++d){for(var p=new Uint32Array(80),f=0;f<16;++f)p[f]=a[d][f];for(var y=16;y<80;++y)p[y]=pr(p[y-3]^p[y-8]^p[y-14]^p[y-16],1);for(var g=t[0],h=t[1],k=t[2],x=t[3],w=t[4],R=0;R<80;++R){var W=Math.floor(R/20),F=pr(g,5)+ka(W,h,k,x)+w+e[W]+p[R]>>>0;w=x,x=k,k=pr(h,30)>>>0,h=g,g=F}t[0]=t[0]+g>>>0,t[1]=t[1]+h>>>0,t[2]=t[2]+k>>>0,t[3]=t[3]+x>>>0,t[4]=t[4]+w>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var Ia=wo("v5",80,Sa);const xa="00000000-0000-0000-0000-000000000000";function Aa(r){if(!Hr(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)}const Ea=Object.freeze(Object.defineProperty({__proto__:null,NIL:xa,parse:mo,stringify:qr,v1:la,v3:wa,v4:ia,v5:Ia,validate:Hr,version:Aa},Symbol.toStringTag,{value:"Module"}));function Bs(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function _a(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Jn(r,...e){if(!_a(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function va(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Bs(r.outputLen),Bs(r.blockLen)}function zn(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Ba(r,e){Jn(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const Jt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const gr=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),it=(r,e)=>r<<32-e|r>>>e;function Ra(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function $r(r){return typeof r=="string"&&(r=Ra(r)),Jn(r),r}function Pa(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];Jn(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const o=r[n];t.set(o,s),s+=o.length}return t}let So=class{clone(){return this._cloneInto()}};function Io(r){const e=n=>r().update($r(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function xo(r=32){if(Jt&&typeof Jt.getRandomValues=="function")return Jt.getRandomValues(new Uint8Array(r));if(Jt&&typeof Jt.randomBytes=="function")return Jt.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function Ta(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(t>>s&o),a=Number(t&o),c=n?4:0,u=n?0:4;r.setUint32(e+c,i,n),r.setUint32(e+u,a,n)}const La=(r,e,t)=>r&e^~r&t,Ca=(r,e,t)=>r&e^r&t^e&t;let Ao=class extends So{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=gr(this.buffer)}update(e){zn(this);const{view:t,buffer:n,blockLen:s}=this;e=$r(e);const o=e.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=gr(e);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){zn(this),Ba(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let d=i;d<s;d++)t[d]=0;Ta(n,s-8,BigInt(this.length*8),o),this.process(n,0);const a=gr(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)a.setUint32(4*d,l[d],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return e.length=s,e.pos=a,e.finished=o,e.destroyed=i,s%t&&e.buffer.set(n),e}};const Pn=BigInt(2**32-1),Cr=BigInt(32);function Eo(r,e=!1){return e?{h:Number(r&Pn),l:Number(r>>Cr&Pn)}:{h:Number(r>>Cr&Pn)|0,l:Number(r&Pn)|0}}function Oa(r,e=!1){let t=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){const{h:o,l:i}=Eo(r[s],e);[t[s],n[s]]=[o,i]}return[t,n]}const Ua=(r,e)=>BigInt(r>>>0)<<Cr|BigInt(e>>>0),Na=(r,e,t)=>r>>>t,za=(r,e,t)=>r<<32-t|e>>>t,Ka=(r,e,t)=>r>>>t|e<<32-t,Wa=(r,e,t)=>r<<32-t|e>>>t,Fa=(r,e,t)=>r<<64-t|e>>>t-32,Da=(r,e,t)=>r>>>t-32|e<<64-t,qa=(r,e)=>e,Ha=(r,e)=>r,Ma=(r,e,t)=>r<<t|e>>>32-t,$a=(r,e,t)=>e<<t|r>>>32-t,Va=(r,e,t)=>e<<t-32|r>>>64-t,ja=(r,e,t)=>r<<t-32|e>>>64-t;function Ga(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const Ya=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),Za=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,Ja=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),Xa=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,Qa=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),ec=(r,e,t,n,s,o)=>e+t+n+s+o+(r/2**32|0)|0,G={fromBig:Eo,split:Oa,toBig:Ua,shrSH:Na,shrSL:za,rotrSH:Ka,rotrSL:Wa,rotrBH:Fa,rotrBL:Da,rotr32H:qa,rotr32L:Ha,rotlSH:Ma,rotlSL:$a,rotlBH:Va,rotlBL:ja,add:Ga,add3L:Ya,add3H:Za,add4L:Ja,add4H:Xa,add5H:ec,add5L:Qa},[tc,nc]=G.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),_t=new Uint32Array(80),vt=new Uint32Array(80);class rc extends Ao{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:d,Fl:p,Gh:f,Gl:y,Hh:g,Hl:h}=this;return[e,t,n,s,o,i,a,c,u,l,d,p,f,y,g,h]}set(e,t,n,s,o,i,a,c,u,l,d,p,f,y,g,h){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=d|0,this.Fl=p|0,this.Gh=f|0,this.Gl=y|0,this.Hh=g|0,this.Hl=h|0}process(e,t){for(let w=0;w<16;w++,t+=4)_t[w]=e.getUint32(t),vt[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const R=_t[w-15]|0,W=vt[w-15]|0,F=G.rotrSH(R,W,1)^G.rotrSH(R,W,8)^G.shrSH(R,W,7),N=G.rotrSL(R,W,1)^G.rotrSL(R,W,8)^G.shrSL(R,W,7),q=_t[w-2]|0,D=vt[w-2]|0,ge=G.rotrSH(q,D,19)^G.rotrBH(q,D,61)^G.shrSH(q,D,6),re=G.rotrSL(q,D,19)^G.rotrBL(q,D,61)^G.shrSL(q,D,6),Q=G.add4L(N,re,vt[w-7],vt[w-16]),xe=G.add4H(Q,F,ge,_t[w-7],_t[w-16]);_t[w]=xe|0,vt[w]=Q|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:d,El:p,Fh:f,Fl:y,Gh:g,Gl:h,Hh:k,Hl:x}=this;for(let w=0;w<80;w++){const R=G.rotrSH(d,p,14)^G.rotrSH(d,p,18)^G.rotrBH(d,p,41),W=G.rotrSL(d,p,14)^G.rotrSL(d,p,18)^G.rotrBL(d,p,41),F=d&f^~d&g,N=p&y^~p&h,q=G.add5L(x,W,N,nc[w],vt[w]),D=G.add5H(q,k,R,F,tc[w],_t[w]),ge=q|0,re=G.rotrSH(n,s,28)^G.rotrBH(n,s,34)^G.rotrBH(n,s,39),Q=G.rotrSL(n,s,28)^G.rotrBL(n,s,34)^G.rotrBL(n,s,39),xe=n&o^n&a^o&a,L=s&i^s&c^i&c;k=g|0,x=h|0,g=f|0,h=y|0,f=d|0,y=p|0,{h:d,l:p}=G.add(u|0,l|0,D|0,ge|0),u=a|0,l=c|0,a=o|0,c=i|0,o=n|0,i=s|0;const z=G.add3L(ge,Q,L);n=G.add3H(z,D,re,xe),s=z|0}({h:n,l:s}=G.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=G.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=G.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=G.add(this.Dh|0,this.Dl|0,u|0,l|0),{h:d,l:p}=G.add(this.Eh|0,this.El|0,d|0,p|0),{h:f,l:y}=G.add(this.Fh|0,this.Fl|0,f|0,y|0),{h:g,l:h}=G.add(this.Gh|0,this.Gl|0,g|0,h|0),{h:k,l:x}=G.add(this.Hh|0,this.Hl|0,k|0,x|0),this.set(n,s,o,i,a,c,u,l,d,p,f,y,g,h,k,x)}roundClean(){_t.fill(0),vt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const sc=Io(()=>new rc);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xn=BigInt(0),Qn=BigInt(1),oc=BigInt(2);function Mt(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function An(r){if(!Mt(r))throw new Error("Uint8Array expected")}function xt(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}const ic=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function $t(r){An(r);let e="";for(let t=0;t<r.length;t++)e+=ic[r[t]];return e}function Qt(r){const e=r.toString(16);return e.length&1?"0"+e:e}function Vr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Xn:BigInt("0x"+r)}const bt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Rs(r){if(r>=bt._0&&r<=bt._9)return r-bt._0;if(r>=bt.A&&r<=bt.F)return r-(bt.A-10);if(r>=bt.a&&r<=bt.f)return r-(bt.a-10)}function tn(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,o=0;s<t;s++,o+=2){const i=Rs(r.charCodeAt(o)),a=Rs(r.charCodeAt(o+1));if(i===void 0||a===void 0){const c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function qt(r){return Vr($t(r))}function en(r){return An(r),Vr($t(Uint8Array.from(r).reverse()))}function nn(r,e){return tn(r.toString(16).padStart(e*2,"0"))}function wn(r,e){return nn(r,e).reverse()}function ac(r){return tn(Qt(r))}function Ie(r,e,t){let n;if(typeof e=="string")try{n=tn(e)}catch(o){throw new Error(r+" must be hex string or Uint8Array, cause: "+o)}else if(Mt(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(r+" of length "+t+" expected, got "+s);return n}function Vt(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];An(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const o=r[n];t.set(o,s),s+=o.length}return t}function cc(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function uc(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}const yr=r=>typeof r=="bigint"&&Xn<=r;function er(r,e,t){return yr(r)&&yr(e)&&yr(t)&&e<=r&&r<t}function et(r,e,t,n){if(!er(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function _o(r){let e;for(e=0;r>Xn;r>>=Qn,e+=1);return e}function lc(r,e){return r>>BigInt(e)&Qn}function dc(r,e,t){return r|(t?Qn:Xn)<<BigInt(e)}const jr=r=>(oc<<BigInt(r-1))-Qn,br=r=>new Uint8Array(r),Ps=r=>Uint8Array.from(r);function vo(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=br(r),s=br(r),o=0;const i=()=>{n.fill(1),s.fill(0),o=0},a=(...d)=>t(s,n,...d),c=(d=br())=>{s=a(Ps([0]),d),n=a(),d.length!==0&&(s=a(Ps([1]),d),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const p=[];for(;d<e;){n=a();const f=n.slice();p.push(f),d+=n.length}return Vt(...p)};return(d,p)=>{i(),c(d);let f;for(;!(f=p(u()));)c();return i(),f}}const hc={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||Mt(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function cn(r,e,t={}){const n=(s,o,i)=>{const a=hc[o];if(typeof a!="function")throw new Error("invalid validator function");const c=r[s];if(!(i&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+c)};for(const[s,o]of Object.entries(e))n(s,o,!1);for(const[s,o]of Object.entries(t))n(s,o,!0);return r}const fc=()=>{throw new Error("not implemented")};function kn(r){const e=new WeakMap;return(t,...n)=>{const s=e.get(t);if(s!==void 0)return s;const o=r(t,...n);return e.set(t,o),o}}const pc=Object.freeze(Object.defineProperty({__proto__:null,aInRange:et,abool:xt,abytes:An,bitGet:lc,bitLen:_o,bitMask:jr,bitSet:dc,bytesToHex:$t,bytesToNumberBE:qt,bytesToNumberLE:en,concatBytes:Vt,createHmacDrbg:vo,ensureBytes:Ie,equalBytes:cc,hexToBytes:tn,hexToNumber:Vr,inRange:er,isBytes:Mt,memoized:kn,notImplemented:fc,numberToBytesBE:nn,numberToBytesLE:wn,numberToHexUnpadded:Qt,numberToVarBytesBE:ac,utf8ToBytes:uc,validateObject:cn},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Re=BigInt(0),me=BigInt(1),zt=BigInt(2),gc=BigInt(3),Or=BigInt(4),Ts=BigInt(5),Ls=BigInt(8);function ye(r,e){const t=r%e;return t>=Re?t:e+t}function yc(r,e,t){if(e<Re)throw new Error("invalid exponent, negatives unsupported");if(t<=Re)throw new Error("invalid modulus");if(t===me)return Re;let n=me;for(;e>Re;)e&me&&(n=n*r%t),r=r*r%t,e>>=me;return n}function ke(r,e,t){let n=r;for(;e-- >Re;)n*=n,n%=t;return n}function Ur(r,e){if(r===Re)throw new Error("invert: expected non-zero number");if(e<=Re)throw new Error("invert: expected positive modulus, got "+e);let t=ye(r,e),n=e,s=Re,o=me;for(;t!==Re;){const a=n/t,c=n%t,u=s-o*a;n=t,t=c,s=o,o=u}if(n!==me)throw new Error("invert: does not exist");return ye(s,e)}function bc(r){const e=(r-me)/zt;let t,n,s;for(t=r-me,n=0;t%zt===Re;t/=zt,n++);for(s=zt;s<r&&yc(s,e,r)!==r-me;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){const i=(r+me)/Or;return function(c,u){const l=c.pow(u,i);if(!c.eql(c.sqr(l),u))throw new Error("Cannot find square root");return l}}const o=(t+me)/zt;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=n,l=a.pow(a.mul(a.ONE,s),t),d=a.pow(c,o),p=a.pow(c,t);for(;!a.eql(p,a.ONE);){if(a.eql(p,a.ZERO))return a.ZERO;let f=1;for(let g=a.sqr(p);f<u&&!a.eql(g,a.ONE);f++)g=a.sqr(g);const y=a.pow(l,me<<BigInt(u-f-1));l=a.sqr(y),d=a.mul(d,y),p=a.mul(p,l),u=f}return d}}function mc(r){if(r%Or===gc){const e=(r+me)/Or;return function(n,s){const o=n.pow(s,e);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%Ls===Ts){const e=(r-Ts)/Ls;return function(n,s){const o=n.mul(s,zt),i=n.pow(o,e),a=n.mul(s,i),c=n.mul(n.mul(a,zt),i),u=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(u),s))throw new Error("Cannot find square root");return u}}return bc(r)}const wc=(r,e)=>(ye(r,e)&me)===me,kc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Sc(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=kc.reduce((n,s)=>(n[s]="function",n),e);return cn(r,t)}function Ic(r,e,t){if(t<Re)throw new Error("invalid exponent, negatives unsupported");if(t===Re)return r.ONE;if(t===me)return e;let n=r.ONE,s=e;for(;t>Re;)t&me&&(n=r.mul(n,s)),s=r.sqr(s),t>>=me;return n}function xc(r,e){const t=new Array(e.length),n=e.reduce((o,i,a)=>r.is0(i)?o:(t[a]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return e.reduceRight((o,i,a)=>r.is0(i)?o:(t[a]=r.mul(o,t[a]),r.mul(o,i)),s),t}function Bo(r,e){const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function tr(r,e,t=!1,n={}){if(r<=Re)throw new Error("invalid field: expected ORDER > 0, got "+r);const{nBitLength:s,nByteLength:o}=Bo(r,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i;const a=Object.freeze({ORDER:r,BITS:s,BYTES:o,MASK:jr(s),ZERO:Re,ONE:me,create:c=>ye(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return Re<=c&&c<r},is0:c=>c===Re,isOdd:c=>(c&me)===me,neg:c=>ye(-c,r),eql:(c,u)=>c===u,sqr:c=>ye(c*c,r),add:(c,u)=>ye(c+u,r),sub:(c,u)=>ye(c-u,r),mul:(c,u)=>ye(c*u,r),pow:(c,u)=>Ic(a,c,u),div:(c,u)=>ye(c*Ur(u,r),r),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>Ur(c,r),sqrt:n.sqrt||(c=>(i||(i=mc(r)),i(a,c))),invertBatch:c=>xc(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>t?wn(c,o):nn(c,o),fromBytes:c=>{if(c.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+c.length);return t?en(c):qt(c)}});return Object.freeze(a)}function Ro(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function Po(r){const e=Ro(r);return e+Math.ceil(e/2)}function Ac(r,e,t=!1){const n=r.length,s=Ro(e),o=Po(e);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);const i=t?qt(r):en(r),a=ye(i,e-me)+me;return t?wn(a,s):nn(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Cs=BigInt(0),Tn=BigInt(1);function mr(r,e){const t=e.negate();return r?t:e}function To(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function wr(r,e){To(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1);return{windows:t,windowSize:n}}function Ec(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function _c(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const kr=new WeakMap,Lo=new WeakMap;function Sr(r){return Lo.get(r)||1}function Co(r,e){return{constTimeNegate:mr,hasPrecomputes(t){return Sr(t)!==1},unsafeLadder(t,n,s=r.ZERO){let o=t;for(;n>Cs;)n&Tn&&(s=s.add(o)),o=o.double(),n>>=Tn;return s},precomputeWindow(t,n){const{windows:s,windowSize:o}=wr(n,e),i=[];let a=t,c=a;for(let u=0;u<s;u++){c=a,i.push(c);for(let l=1;l<o;l++)c=c.add(a),i.push(c);a=c.double()}return i},wNAF(t,n,s){const{windows:o,windowSize:i}=wr(t,e);let a=r.ZERO,c=r.BASE;const u=BigInt(2**t-1),l=2**t,d=BigInt(t);for(let p=0;p<o;p++){const f=p*i;let y=Number(s&u);s>>=d,y>i&&(y-=l,s+=Tn);const g=f,h=f+Math.abs(y)-1,k=p%2!==0,x=y<0;y===0?c=c.add(mr(k,n[g])):a=a.add(mr(x,n[h]))}return{p:a,f:c}},wNAFUnsafe(t,n,s,o=r.ZERO){const{windows:i,windowSize:a}=wr(t,e),c=BigInt(2**t-1),u=2**t,l=BigInt(t);for(let d=0;d<i;d++){const p=d*a;if(s===Cs)break;let f=Number(s&c);if(s>>=l,f>a&&(f-=u,s+=Tn),f===0)continue;let y=n[p+Math.abs(f)-1];f<0&&(y=y.negate()),o=o.add(y)}return o},getPrecomputes(t,n,s){let o=kr.get(n);return o||(o=this.precomputeWindow(n,t),t!==1&&kr.set(n,s(o))),o},wNAFCached(t,n,s){const o=Sr(t);return this.wNAF(o,this.getPrecomputes(o,t,s),n)},wNAFCachedUnsafe(t,n,s,o){const i=Sr(t);return i===1?this.unsafeLadder(t,n,o):this.wNAFUnsafe(i,this.getPrecomputes(i,t,s),n,o)},setWindowSize(t,n){To(n,e),Lo.set(t,n),kr.delete(t)}}}function Oo(r,e,t,n){if(Ec(t,r),_c(n,e),t.length!==n.length)throw new Error("arrays of points and scalars must have equal length");const s=r.ZERO,o=_o(BigInt(t.length)),i=o>12?o-3:o>4?o-2:o?2:1,a=(1<<i)-1,c=new Array(a+1).fill(s),u=Math.floor((e.BITS-1)/i)*i;let l=s;for(let d=u;d>=0;d-=i){c.fill(s);for(let f=0;f<n.length;f++){const y=n[f],g=Number(y>>BigInt(d)&BigInt(a));c[g]=c[g].add(t[f])}let p=s;for(let f=c.length-1,y=s;f>0;f--)y=y.add(c[f]),p=p.add(y);if(l=l.add(p),d!==0)for(let f=0;f<i;f++)l=l.double()}return l}function Gr(r){return Sc(r.Fp),cn(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Bo(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nt=BigInt(0),Ve=BigInt(1),Ln=BigInt(2),vc=BigInt(8),Bc={zip215:!0};function Rc(r){const e=Gr(r);return cn(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Pc(r){const e=Rc(r),{Fp:t,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=e,u=Ln<<BigInt(a*8)-Ve,l=t.create,d=tr(e.n,e.nBitLength),p=e.uvRatio||((A,S)=>{try{return{isValid:!0,value:t.sqrt(A*t.inv(S))}}catch{return{isValid:!1,value:nt}}}),f=e.adjustScalarBytes||(A=>A),y=e.domain||((A,S,_)=>{if(xt("phflag",_),S.length||_)throw new Error("Contexts/pre-hash are not supported");return A});function g(A,S){et("coordinate "+A,S,nt,u)}function h(A){if(!(A instanceof w))throw new Error("ExtendedPoint expected")}const k=kn((A,S)=>{const{ex:_,ey:C,ez:$}=A,V=A.is0();S==null&&(S=V?vc:t.inv($));const J=l(_*S),ee=l(C*S),j=l($*S);if(V)return{x:nt,y:Ve};if(j!==Ve)throw new Error("invZ was invalid");return{x:J,y:ee}}),x=kn(A=>{const{a:S,d:_}=e;if(A.is0())throw new Error("bad point: ZERO");const{ex:C,ey:$,ez:V,et:J}=A,ee=l(C*C),j=l($*$),ce=l(V*V),le=l(ce*ce),Ae=l(ee*S),Ee=l(ce*l(Ae+j)),Pe=l(le+l(_*l(ee*j)));if(Ee!==Pe)throw new Error("bad point: equation left != right (1)");const ze=l(C*$),$e=l(V*J);if(ze!==$e)throw new Error("bad point: equation left != right (2)");return!0});class w{constructor(S,_,C,$){this.ex=S,this.ey=_,this.ez=C,this.et=$,g("x",S),g("y",_),g("z",C),g("t",$),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(S){if(S instanceof w)throw new Error("extended point not allowed");const{x:_,y:C}=S||{};return g("x",_),g("y",C),new w(_,C,Ve,l(_*C))}static normalizeZ(S){const _=t.invertBatch(S.map(C=>C.ez));return S.map((C,$)=>C.toAffine(_[$])).map(w.fromAffine)}static msm(S,_){return Oo(w,d,S,_)}_setWindowSize(S){F.setWindowSize(this,S)}assertValidity(){x(this)}equals(S){h(S);const{ex:_,ey:C,ez:$}=this,{ex:V,ey:J,ez:ee}=S,j=l(_*ee),ce=l(V*$),le=l(C*ee),Ae=l(J*$);return j===ce&&le===Ae}is0(){return this.equals(w.ZERO)}negate(){return new w(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:S}=e,{ex:_,ey:C,ez:$}=this,V=l(_*_),J=l(C*C),ee=l(Ln*l($*$)),j=l(S*V),ce=_+C,le=l(l(ce*ce)-V-J),Ae=j+J,Ee=Ae-ee,Pe=j-J,ze=l(le*Ee),$e=l(Ae*Pe),qe=l(le*Pe),ot=l(Ee*Ae);return new w(ze,$e,ot,qe)}add(S){h(S);const{a:_,d:C}=e,{ex:$,ey:V,ez:J,et:ee}=this,{ex:j,ey:ce,ez:le,et:Ae}=S;if(_===BigInt(-1)){const ws=l((V-$)*(ce+j)),ks=l((V+$)*(ce-j)),lr=l(ks-ws);if(lr===nt)return this.double();const Ss=l(J*Ln*Ae),Is=l(ee*Ln*le),xs=Is+Ss,As=ks+ws,Es=Is-Ss,Qi=l(xs*lr),ea=l(As*Es),ta=l(xs*Es),na=l(lr*As);return new w(Qi,ea,na,ta)}const Ee=l($*j),Pe=l(V*ce),ze=l(ee*C*Ae),$e=l(J*le),qe=l(($+V)*(j+ce)-Ee-Pe),ot=$e-ze,Et=$e+ze,yt=l(Pe-_*Ee),Yi=l(qe*ot),Zi=l(Et*yt),Ji=l(qe*yt),Xi=l(ot*Et);return new w(Yi,Zi,Xi,Ji)}subtract(S){return this.add(S.negate())}wNAF(S){return F.wNAFCached(this,S,w.normalizeZ)}multiply(S){const _=S;et("scalar",_,Ve,n);const{p:C,f:$}=this.wNAF(_);return w.normalizeZ([C,$])[0]}multiplyUnsafe(S,_=w.ZERO){const C=S;return et("scalar",C,nt,n),C===nt?W:this.is0()||C===Ve?this:F.wNAFCachedUnsafe(this,C,w.normalizeZ,_)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return F.unsafeLadder(this,n).is0()}toAffine(S){return k(this,S)}clearCofactor(){const{h:S}=e;return S===Ve?this:this.multiplyUnsafe(S)}static fromHex(S,_=!1){const{d:C,a:$}=e,V=t.BYTES;S=Ie("pointHex",S,V),xt("zip215",_);const J=S.slice(),ee=S[V-1];J[V-1]=ee&-129;const j=en(J),ce=_?u:t.ORDER;et("pointHex.y",j,nt,ce);const le=l(j*j),Ae=l(le-Ve),Ee=l(C*le-$);let{isValid:Pe,value:ze}=p(Ae,Ee);if(!Pe)throw new Error("Point.fromHex: invalid y coordinate");const $e=(ze&Ve)===Ve,qe=(ee&128)!==0;if(!_&&ze===nt&&qe)throw new Error("Point.fromHex: x=0 and x_0=1");return qe!==$e&&(ze=l(-ze)),w.fromAffine({x:ze,y:j})}static fromPrivateKey(S){return D(S).point}toRawBytes(){const{x:S,y:_}=this.toAffine(),C=wn(_,t.BYTES);return C[C.length-1]|=S&Ve?128:0,C}toHex(){return $t(this.toRawBytes())}}w.BASE=new w(e.Gx,e.Gy,Ve,l(e.Gx*e.Gy)),w.ZERO=new w(nt,Ve,Ve,nt);const{BASE:R,ZERO:W}=w,F=Co(w,a*8);function N(A){return ye(A,n)}function q(A){return N(en(A))}function D(A){const S=t.BYTES;A=Ie("private key",A,S);const _=Ie("hashed private key",o(A),2*S),C=f(_.slice(0,S)),$=_.slice(S,2*S),V=q(C),J=R.multiply(V),ee=J.toRawBytes();return{head:C,prefix:$,scalar:V,point:J,pointBytes:ee}}function ge(A){return D(A).pointBytes}function re(A=new Uint8Array,...S){const _=Vt(...S);return q(o(y(_,Ie("context",A),!!s)))}function Q(A,S,_={}){A=Ie("message",A),s&&(A=s(A));const{prefix:C,scalar:$,pointBytes:V}=D(S),J=re(_.context,C,A),ee=R.multiply(J).toRawBytes(),j=re(_.context,ee,V,A),ce=N(J+j*$);et("signature.s",ce,nt,n);const le=Vt(ee,wn(ce,t.BYTES));return Ie("result",le,t.BYTES*2)}const xe=Bc;function L(A,S,_,C=xe){const{context:$,zip215:V}=C,J=t.BYTES;A=Ie("signature",A,2*J),S=Ie("message",S),_=Ie("publicKey",_,J),V!==void 0&&xt("zip215",V),s&&(S=s(S));const ee=en(A.slice(J,2*J));let j,ce,le;try{j=w.fromHex(_,V),ce=w.fromHex(A.slice(0,J),V),le=R.multiplyUnsafe(ee)}catch{return!1}if(!V&&j.isSmallOrder())return!1;const Ae=re($,ce.toRawBytes(),j.toRawBytes(),S);return ce.add(j.multiplyUnsafe(Ae)).subtract(le).clearCofactor().equals(w.ZERO)}return R._setWindowSize(8),{CURVE:e,getPublicKey:ge,sign:Q,verify:L,ExtendedPoint:w,utils:{getExtendedPublicKey:D,randomPrivateKey:()=>i(t.BYTES),precompute(A=8,S=w.BASE){return S._setWindowSize(A),S.multiply(BigInt(3)),S}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Os=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Tc=BigInt(1),Us=BigInt(2);BigInt(3);const Lc=BigInt(5),Cc=BigInt(8);function Oc(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),o=Yr,a=r*r%o*r%o,c=ke(a,Us,o)*a%o,u=ke(c,Tc,o)*r%o,l=ke(u,Lc,o)*u%o,d=ke(l,e,o)*l%o,p=ke(d,t,o)*d%o,f=ke(p,n,o)*p%o,y=ke(f,s,o)*f%o,g=ke(y,s,o)*f%o,h=ke(g,e,o)*l%o;return{pow_p_5_8:ke(h,Us,o)*r%o,b2:a}}function Uc(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Nc(r,e){const t=Yr,n=ye(e*e*e,t),s=ye(n*n*e,t),o=Oc(r*s).pow_p_5_8;let i=ye(r*n*o,t);const a=ye(e*i*i,t),c=i,u=ye(i*Os,t),l=a===r,d=a===ye(-r,t),p=a===ye(-r*Os,t);return l&&(i=c),(d||p)&&(i=u),wc(i,t)&&(i=ye(-i,t)),{isValid:l||d,value:i}}const zc=tr(Yr,void 0,!0),Kc={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:zc,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Cc,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:sc,randomBytes:xo,adjustScalarBytes:Uc,uvRatio:Nc},un=Pc(Kc);var Cn=aa.Buffer;function Wc(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,a=r.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function l(f){if((Array.isArray(f)||f instanceof Uint8Array)&&(f=Cn.from(f)),!Cn.isBuffer(f))throw new TypeError("Expected Buffer");if(f.length===0)return"";for(var y=0,g=0,h=0,k=f.length;h!==k&&f[h]===0;)h++,y++;for(var x=(k-h)*u+1>>>0,w=new Uint8Array(x);h!==k;){for(var R=f[h],W=0,F=x-1;(R!==0||W<g)&&F!==-1;F--,W++)R+=256*w[F]>>>0,w[F]=R%i>>>0,R=R/i>>>0;if(R!==0)throw new Error("Non-zero carry");g=W,h++}for(var N=x-g;N!==x&&w[N]===0;)N++;for(var q=a.repeat(y);N<x;++N)q+=r.charAt(w[N]);return q}function d(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return Cn.alloc(0);for(var y=0,g=0,h=0;f[y]===a;)g++,y++;for(var k=(f.length-y)*c+1>>>0,x=new Uint8Array(k);y<f.length;){var w=e[f.charCodeAt(y)];if(w===255)return;for(var R=0,W=k-1;(w!==0||R<h)&&W!==-1;W--,R++)w+=i*x[W]>>>0,x[W]=w%256>>>0,w=w/256>>>0;if(w!==0)throw new Error("Non-zero carry");h=R,y++}for(var F=k-h;F!==k&&x[F]===0;)F++;var N=Cn.allocUnsafe(g+(k-F));N.fill(0,0,g);for(var q=g;F!==k;)N[q++]=x[F++];return N}function p(f){var y=d(f);if(y)return y;throw new Error("Non-base"+i+" character")}return{encode:l,decodeUnsafe:d,decode:p}}var Fc=Wc,Dc=Fc,qc="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",Uo=Dc(qc);const Oe=Mr(Uo);function Ns(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Hc(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Zr(r,...e){if(!Hc(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function Kn(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function No(r,e){Zr(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Mc=r=>new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4)),Ir=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),at=(r,e)=>r<<32-e|r>>>e,zs=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,$c=r=>r<<24&4278190080|r<<8&16711680|r>>>8&65280|r>>>24&255;function Ks(r){for(let e=0;e<r.length;e++)r[e]=$c(r[e])}function Vc(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function Jr(r){return typeof r=="string"&&(r=Vc(r)),Zr(r),r}class zo{clone(){return this._cloneInto()}}function Ko(r){const e=n=>r().update(Jr(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function jc(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(t>>s&o),a=Number(t&o),c=n?4:0,u=n?0:4;r.setUint32(e+c,i,n),r.setUint32(e+u,a,n)}const Gc=(r,e,t)=>r&e^~r&t,Yc=(r,e,t)=>r&e^r&t^e&t;class Zc extends zo{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Ir(this.buffer)}update(e){Kn(this);const{view:t,buffer:n,blockLen:s}=this;e=Jr(e);const o=e.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=Ir(e);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Kn(this),No(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let d=i;d<s;d++)t[d]=0;jc(n,s-8,BigInt(this.length*8),o),this.process(n,0);const a=Ir(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)a.setUint32(4*d,l[d],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return e.length=s,e.pos=a,e.finished=o,e.destroyed=i,s%t&&e.buffer.set(n),e}}const Jc=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Bt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Rt=new Uint32Array(64);let Xc=class extends Zc{constructor(){super(64,32,8,!1),this.A=Bt[0]|0,this.B=Bt[1]|0,this.C=Bt[2]|0,this.D=Bt[3]|0,this.E=Bt[4]|0,this.F=Bt[5]|0,this.G=Bt[6]|0,this.H=Bt[7]|0}get(){const{A:e,B:t,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[e,t,n,s,o,i,a,c]}set(e,t,n,s,o,i,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)Rt[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const p=Rt[d-15],f=Rt[d-2],y=at(p,7)^at(p,18)^p>>>3,g=at(f,17)^at(f,19)^f>>>10;Rt[d]=g+Rt[d-7]+y+Rt[d-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:u,H:l}=this;for(let d=0;d<64;d++){const p=at(a,6)^at(a,11)^at(a,25),f=l+p+Gc(a,c,u)+Jc[d]+Rt[d]|0,g=(at(n,2)^at(n,13)^at(n,22))+Yc(n,s,o)|0;l=u,u=c,c=a,a=i+f|0,i=o,o=s,s=n,n=f+g|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,o,i,a,c,u,l)}roundClean(){Rt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const Ws=Ko(()=>new Xc);var Ce={};function kt(r,e,t){return e<=r&&r<=t}function nr(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function Qc(r){for(var e=String(r),t=e.length,n=0,s=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)s.push(65533);else{var i=r.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),n+=1}else s.push(65533)}n+=1}return s}function eu(r){for(var e="",t=0;t<r.length;++t){var n=r[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var Wn=-1;function Xr(r){this.tokens=[].slice.call(r)}Xr.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():Wn},prepend:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.push(e.shift());else this.tokens.push(r)}};var rn=-1;function xr(r,e){if(r)throw TypeError("Decoder error");return e||65533}var Fn="utf-8";function Dn(r,e){if(!(this instanceof Dn))return new Dn(r,e);if(r=r!==void 0?String(r).toLowerCase():Fn,r!==Fn)throw new Error("Encoding not supported. Only utf-8 is supported");e=nr(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}Dn.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=nr(t),this._streaming||(this._decoder=new tu({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new Xr(n),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==rn);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===rn)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),eu(o)}};function qn(r,e){if(!(this instanceof qn))return new qn(r,e);if(r=r!==void 0?String(r).toLowerCase():Fn,r!==Fn)throw new Error("Encoding not supported. Only utf-8 is supported");e=nr(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}qn.prototype={encode:function(e,t){e=e?String(e):"",t=nr(t),this._streaming||(this._encoder=new nu(this._options)),this._streaming=!!t.stream;for(var n=[],s=new Xr(Qc(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==rn);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==rn;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function tu(r){var e=r.fatal,t=0,n=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===Wn&&s!==0)return s=0,xr(e);if(c===Wn)return rn;if(s===0){if(kt(c,0,127))return c;if(kt(c,194,223))s=1,t=c-192;else if(kt(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(kt(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return xr(e);return t=t<<6*s,null}if(!kt(c,o,i))return t=s=n=0,o=128,i=191,a.prepend(c),xr(e);if(o=128,i=191,n+=1,t+=c-128<<6*(s-n),n!==s)return null;var u=t;return t=s=n=0,u}}function nu(r){r.fatal,this.handler=function(e,t){if(t===Wn)return rn;if(kt(t,0,127))return t;var n,s;kt(t,128,2047)?(n=1,s=192):kt(t,2048,65535)?(n=2,s=224):kt(t,65536,1114111)&&(n=3,s=240);for(var o=[(t>>6*n)+s];n>0;){var i=t>>6*(n-1);o.push(128|i&63),n-=1}return o}}const ru=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:Dn,TextEncoder:qn},Symbol.toStringTag,{value:"Module"})),su=bo(ru);var ou=lt&&lt.__createBinding||(Object.create?function(r,e,t,n){n===void 0&&(n=t),Object.defineProperty(r,n,{enumerable:!0,get:function(){return e[t]}})}:function(r,e,t,n){n===void 0&&(n=t),r[n]=e[t]}),iu=lt&&lt.__setModuleDefault||(Object.create?function(r,e){Object.defineProperty(r,"default",{enumerable:!0,value:e})}:function(r,e){r.default=e}),ft=lt&&lt.__decorate||function(r,e,t,n){var s=arguments.length,o=s<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(r,e,t,n);else for(var a=r.length-1;a>=0;a--)(i=r[a])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},au=lt&&lt.__importStar||function(r){if(r&&r.__esModule)return r;var e={};if(r!=null)for(var t in r)t!=="default"&&Object.hasOwnProperty.call(r,t)&&ou(e,r,t);return iu(e,r),e},Wo=lt&&lt.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(Ce,"__esModule",{value:!0});var Fo=Ce.deserializeUnchecked=Vo=Ce.deserialize=$o=Ce.serialize=Ce.BinaryReader=Ce.BinaryWriter=Ce.BorshError=Ce.baseDecode=Ce.baseEncode=void 0;const Ut=Wo(ca),Do=Wo(Uo),cu=au(su),uu=typeof TextDecoder!="function"?cu.TextDecoder:TextDecoder,lu=new uu("utf-8",{fatal:!0});function du(r){return typeof r=="string"&&(r=ve.from(r,"utf8")),Do.default.encode(ve.from(r))}Ce.baseEncode=du;function hu(r){return ve.from(Do.default.decode(r))}Ce.baseDecode=hu;const Ar=1024;class He extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}Ce.BorshError=He;class qo{constructor(){this.buf=ve.alloc(Ar),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=ve.concat([this.buf,ve.alloc(Ar)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(ve.from(new Ut.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(ve.from(new Ut.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(ve.from(new Ut.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(ve.from(new Ut.default(e).toArray("le",64)))}writeBuffer(e){this.buf=ve.concat([ve.from(this.buf.subarray(0,this.length)),e,ve.alloc(Ar)]),this.length+=e.length}writeString(e){this.maybeResize();const t=ve.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(ve.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}Ce.BinaryWriter=qo;function pt(r,e,t){const n=t.value;t.value=function(...s){try{return n.apply(this,s)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new He("Reached the end of buffer when deserializing")}throw o}}}class Xe{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new Ut.default(e,"le")}readU128(){const e=this.readBuffer(16);return new Ut.default(e,"le")}readU256(){const e=this.readBuffer(32);return new Ut.default(e,"le")}readU512(){const e=this.readBuffer(64);return new Ut.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new He(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return lu.decode(t)}catch(n){throw new He(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let s=0;s<t;++s)n.push(e());return n}}ft([pt],Xe.prototype,"readU8",null);ft([pt],Xe.prototype,"readU16",null);ft([pt],Xe.prototype,"readU32",null);ft([pt],Xe.prototype,"readU64",null);ft([pt],Xe.prototype,"readU128",null);ft([pt],Xe.prototype,"readU256",null);ft([pt],Xe.prototype,"readU512",null);ft([pt],Xe.prototype,"readString",null);ft([pt],Xe.prototype,"readFixedArray",null);ft([pt],Xe.prototype,"readArray",null);Ce.BinaryReader=Xe;function Ho(r){return r.charAt(0).toUpperCase()+r.slice(1)}function Kt(r,e,t,n,s){try{if(typeof n=="string")s[`write${Ho(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new He(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new He(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)Kt(r,null,t[o],n[0],s)}else s.writeArray(t,o=>{Kt(r,e,o,n[0],s)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),Kt(r,e,t,n.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{Kt(r,e,i,n.key,s),Kt(r,e,o,n.value,s)});break}default:throw new He(`FieldType ${n} unrecognized`)}else Mo(r,t,s)}catch(o){throw o instanceof He&&o.addToFieldPath(e),o}}function Mo(r,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=r.get(e.constructor);if(!n)throw new He(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([s,o])=>{Kt(r,s,e[s],o,t)});else if(n.kind==="enum"){const s=e[n.field];for(let o=0;o<n.values.length;++o){const[i,a]=n.values[o];if(i===s){t.writeU8(o),Kt(r,i,e[i],a,t);break}}}else throw new He(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function fu(r,e,t=qo){const n=new t;return Mo(r,e,n),n.toArray()}var $o=Ce.serialize=fu;function Wt(r,e,t,n){try{if(typeof t=="string")return n[`read${Ho(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const s=[];for(let o=0;o<t[1];o++)s.push(Wt(r,null,t[0],n));return s}else return n.readArray(()=>Wt(r,e,t[0],n))}if(t.kind==="option")return n.readU8()?Wt(r,e,t.type,n):void 0;if(t.kind==="map"){let s=new Map;const o=n.readU32();for(let i=0;i<o;i++){const a=Wt(r,e,t.key,n),c=Wt(r,e,t.value,n);s.set(a,c)}return s}return Qr(r,t,n)}catch(s){throw s instanceof He&&s.addToFieldPath(e),s}}function Qr(r,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=r.get(e);if(!n)throw new He(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const s={};for(const[o,i]of r.get(e).fields)s[o]=Wt(r,o,i,t);return new e(s)}if(n.kind==="enum"){const s=t.readU8();if(s>=n.values.length)throw new He(`Enum index: ${s} is out of range`);const[o,i]=n.values[s],a=Wt(r,o,i,t);return new e({[o]:a})}throw new He(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function pu(r,e,t,n=Xe){const s=new n(t),o=Qr(r,e,s);if(s.offset<t.length)throw new He(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}var Vo=Ce.deserialize=pu;function gu(r,e,t,n=Xe){const s=new n(t);return Qr(r,e,s)}Fo=Ce.deserializeUnchecked=gu;var m={};Object.defineProperty(m,"__esModule",{value:!0});m.s16=m.s8=m.nu64be=m.u48be=m.u40be=m.u32be=m.u24be=m.u16be=Te=m.nu64=m.u48=m.u40=O=m.u32=m.u24=Qe=m.u16=ne=m.u8=Nt=m.offset=m.greedy=m.Constant=m.UTF8=m.CString=m.Blob=m.Boolean=m.BitField=m.BitStructure=m.VariantLayout=m.Union=m.UnionLayoutDiscriminator=m.UnionDiscriminator=m.Structure=m.Sequence=m.DoubleBE=m.Double=m.FloatBE=m.Float=m.NearInt64BE=m.NearInt64=m.NearUInt64BE=m.NearUInt64=m.IntBE=m.Int=m.UIntBE=m.UInt=m.OffsetLayout=m.GreedyCount=m.ExternalLayout=m.bindConstructorLayout=m.nameWithProperty=m.Layout=m.uint8ArrayToBuffer=m.checkUint8Array=void 0;m.constant=m.utf8=m.cstr=pe=m.blob=m.unionLayoutDiscriminator=m.union=Ne=m.seq=m.bits=U=m.struct=m.f64be=m.f64=m.f32be=m.f32=m.ns64be=m.s48be=m.s40be=m.s32be=m.s24be=m.s16be=Ze=m.ns64=m.s48=m.s40=m.s32=m.s24=void 0;const es=ua;function ln(r){if(!(r instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}m.checkUint8Array=ln;function oe(r){return ln(r),es.Buffer.from(r.buffer,r.byteOffset,r.length)}m.uint8ArrayToBuffer=oe;class ue{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}m.Layout=ue;function ts(r,e){return e.property?r+"["+e.property+"]":r}m.nameWithProperty=ts;function yu(r,e){if(typeof r!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(r,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof ue))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");r.layout_=e,e.boundConstructor_=r,e.makeDestinationObject=()=>new r,Object.defineProperty(r.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(r,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}m.bindConstructorLayout=yu;class Ye extends ue{isCount(){throw new Error("ExternalLayout is abstract")}}m.ExternalLayout=Ye;class jo extends Ye{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){ln(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}m.GreedyCount=jo;class ns extends Ye{constructor(e,t=0,n){if(!(e instanceof ue))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof tt||this.layout instanceof rt}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}m.OffsetLayout=ns;class tt extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readUIntLE(t,this.span)}encode(e,t,n=0){return oe(t).writeUIntLE(e,n,this.span),this.span}}m.UInt=tt;class rt extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readUIntBE(t,this.span)}encode(e,t,n=0){return oe(t).writeUIntBE(e,n,this.span),this.span}}m.UIntBE=rt;class jt extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readIntLE(t,this.span)}encode(e,t,n=0){return oe(t).writeIntLE(e,n,this.span),this.span}}m.Int=jt;class dn extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readIntBE(t,this.span)}encode(e,t,n=0){return oe(t).writeIntBE(e,n,this.span),this.span}}m.IntBE=dn;const Nr=Math.pow(2,32);function rr(r){const e=Math.floor(r/Nr),t=r-e*Nr;return{hi32:e,lo32:t}}function sr(r,e){return r*Nr+e}class Go extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),s=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return sr(o,s)}encode(e,t,n=0){const s=rr(e),o=oe(t);return o.writeUInt32LE(s.lo32,n),o.writeUInt32LE(s.hi32,n+4),8}}m.NearUInt64=Go;class Yo extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),s=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return sr(s,o)}encode(e,t,n=0){const s=rr(e),o=oe(t);return o.writeUInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}m.NearUInt64BE=Yo;class Zo extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),s=n.readUInt32LE(t),o=n.readInt32LE(t+4);return sr(o,s)}encode(e,t,n=0){const s=rr(e),o=oe(t);return o.writeUInt32LE(s.lo32,n),o.writeInt32LE(s.hi32,n+4),8}}m.NearInt64=Zo;class Jo extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),s=n.readInt32BE(t),o=n.readUInt32BE(t+4);return sr(s,o)}encode(e,t,n=0){const s=rr(e),o=oe(t);return o.writeInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}m.NearInt64BE=Jo;class Xo extends ue{constructor(e){super(4,e)}decode(e,t=0){return oe(e).readFloatLE(t)}encode(e,t,n=0){return oe(t).writeFloatLE(e,n),4}}m.Float=Xo;class Qo extends ue{constructor(e){super(4,e)}decode(e,t=0){return oe(e).readFloatBE(t)}encode(e,t,n=0){return oe(t).writeFloatBE(e,n),4}}m.FloatBE=Qo;class ei extends ue{constructor(e){super(8,e)}decode(e,t=0){return oe(e).readDoubleLE(t)}encode(e,t,n=0){return oe(t).writeDoubleLE(e,n),8}}m.Double=ei;class ti extends ue{constructor(e){super(8,e)}decode(e,t=0){return oe(e).readDoubleBE(t)}encode(e,t,n=0){return oe(t).writeDoubleBE(e,n),8}}m.DoubleBE=ti;class ni extends ue{constructor(e,t,n){if(!(e instanceof ue))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof Ye&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof Ye)&&0<e.span&&(s=t*e.span),super(s,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,s=this.count;if(s instanceof Ye&&(s=s.decode(e,t)),0<this.elementLayout.span)n=s*this.elementLayout.span;else{let o=0;for(;o<s;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){const n=[];let s=0,o=this.count;for(o instanceof Ye&&(o=o.decode(e,t));s<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return n}encode(e,t,n=0){const s=this.elementLayout,o=e.reduce((i,a)=>i+s.encode(a,t,n+i),0);return this.count instanceof Ye&&this.count.encode(e.length,t,n),o}}m.Sequence=ni;class ri extends ue{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof ue,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((s,o)=>{const i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){ln(e);const n=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(n[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const s=n;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const u=e[a.property];u!==void 0&&(i=a.encode(u,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-s}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}m.Structure=ri;class rs{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}m.UnionDiscriminator=rs;class Hn extends rs{constructor(e,t){if(!(e instanceof Ye&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}m.UnionLayoutDiscriminator=Hn;class ss extends ue{constructor(e,t,n){let s;if(e instanceof tt||e instanceof rt)s=new Hn(new ns(e));else if(e instanceof Ye&&e.isCount())s=new Hn(e);else if(e instanceof rs)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof ue))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof tt||e instanceof rt)&&(o+=s.layout.span)),super(o,n),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof tt||e instanceof rt,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),n=this.makeDestinationObject(),n[s.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){const s=this.getSourceVariant(e);if(s===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return s.encode(e,t,n)}addVariant(e,t,n){const s=new si(this,e,t,n);return this.registry[e]=s,s}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}}m.Union=ss;class si extends ue{constructor(e,t,n,s){if(!(e instanceof ss))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&s===void 0&&(s=n,n=null),n){if(!(n instanceof ue))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+n)),n+s}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+s):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,n+s),o+=this.layout.getSpan(t,n+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}m.VariantLayout=si;function Xt(r){return 0>r&&(r+=4294967296),r}class os extends ue{constructor(e,t,n){if(!(e instanceof tt||e instanceof rt))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=Xt(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){const n=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(const o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){const s=this.word.decode(t,n);this._packedSetValue(s);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new is(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new oi(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}m.BitStructure=os;class is{constructor(e,t,n){if(!(e instanceof os))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const s=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=Xt(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue();return Xt(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==Xt(e&this.valueMask))throw new TypeError(ts("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=Xt(e<<this.start);this.container._packedSetValue(Xt(t&~this.wordMask)|n)}}m.BitField=is;let oi=class extends is{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};m.Boolean=oi;class ii extends ue{constructor(e,t){if(!(e instanceof Ye&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof Ye||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),oe(e).slice(t,t+n)}encode(e,t,n){let s=this.length;if(this.length instanceof Ye&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(ts("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(n+s>t.length)throw new RangeError("encoding overruns Uint8Array");const o=oe(e);return oe(t).write(o.toString("hex"),n,s,"hex"),this.length instanceof Ye&&this.length.encode(s,t,n),s}}m.Blob=ii;class ai extends ue{constructor(e){super(-1,e)}getSpan(e,t=0){ln(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return oe(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=es.Buffer.from(e,"utf8"),o=s.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");const i=oe(t);return s.copy(i,n),i[n+o]=0,o+1}}m.CString=ai;class ci extends ue{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return ln(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return oe(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=es.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(oe(t),n),o}}m.UTF8=ci;class ui extends ue{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}m.Constant=ui;m.greedy=(r,e)=>new jo(r,e);var Nt=m.offset=(r,e,t)=>new ns(r,e,t),ne=m.u8=r=>new tt(1,r),Qe=m.u16=r=>new tt(2,r);m.u24=r=>new tt(3,r);var O=m.u32=r=>new tt(4,r);m.u40=r=>new tt(5,r);m.u48=r=>new tt(6,r);var Te=m.nu64=r=>new Go(r);m.u16be=r=>new rt(2,r);m.u24be=r=>new rt(3,r);m.u32be=r=>new rt(4,r);m.u40be=r=>new rt(5,r);m.u48be=r=>new rt(6,r);m.nu64be=r=>new Yo(r);m.s8=r=>new jt(1,r);m.s16=r=>new jt(2,r);m.s24=r=>new jt(3,r);m.s32=r=>new jt(4,r);m.s40=r=>new jt(5,r);m.s48=r=>new jt(6,r);var Ze=m.ns64=r=>new Zo(r);m.s16be=r=>new dn(2,r);m.s24be=r=>new dn(3,r);m.s32be=r=>new dn(4,r);m.s40be=r=>new dn(5,r);m.s48be=r=>new dn(6,r);m.ns64be=r=>new Jo(r);m.f32=r=>new Xo(r);m.f32be=r=>new Qo(r);m.f64=r=>new ei(r);m.f64be=r=>new ti(r);var U=m.struct=(r,e,t)=>new ri(r,e,t);m.bits=(r,e,t)=>new os(r,e,t);var Ne=m.seq=(r,e,t)=>new ni(r,e,t);m.union=(r,e,t)=>new ss(r,e,t);m.unionLayoutDiscriminator=(r,e)=>new Hn(r,e);var pe=m.blob=(r,e)=>new ii(r,e);m.cstr=r=>new ai(r);m.utf8=(r,e)=>new ci(r,e);m.constant=(r,e)=>new ui(r,e);var En={};Object.defineProperty(En,"__esModule",{value:!0});function bu(r){{const e=ve.from(r);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var mu=En.toBigIntLE=bu;function wu(r){{const e=r.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}En.toBigIntBE=wu;function ku(r,e){{const t=r.toString(16),n=ve.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return n.reverse(),n}}var li=En.toBufferLE=ku;function Su(r,e){{const t=r.toString(16);return ve.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}En.toBufferBE=Su;class Iu extends TypeError{constructor(e,t){let n;const{message:s,explanation:o,...i}=e,{path:a}=e,c=a.length===0?s:`At path: ${a.join(".")} -- ${s}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}}function xu(r){return _n(r)&&typeof r[Symbol.iterator]=="function"}function _n(r){return typeof r=="object"&&r!=null}function Mn(r){return _n(r)&&!Array.isArray(r)}function st(r){return typeof r=="symbol"?r.toString():typeof r=="string"?JSON.stringify(r):`${r}`}function Au(r){const{done:e,value:t}=r.next();return e?void 0:t}function Eu(r,e,t,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${st(n)}\``}=r;return{value:n,type:i,refinement:a,key:s[s.length-1],path:s,branch:o,...r,message:c}}function*Fs(r,e,t,n){xu(r)||(r=[r]);for(const s of r){const o=Eu(s,e,t,n);o&&(yield o)}}function*as(r,e,t={}){const{path:n=[],branch:s=[r],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:s,mask:i};o&&(r=e.coercer(r,a));let c="valid";for(const u of e.validator(r,a))u.explanation=t.message,c="not_valid",yield[u,void 0];for(let[u,l,d]of e.entries(r,a)){const p=as(l,d,{path:u===void 0?n:[...n,u],branch:u===void 0?s:[...s,l],coerce:o,mask:i,message:t.message});for(const f of p)f[0]?(c=f[0].refinement!=null?"not_refined":"not_valid",yield[f[0],void 0]):o&&(l=f[1],u===void 0?r=l:r instanceof Map?r.set(u,l):r instanceof Set?r.add(l):_n(r)&&(l!==void 0||u in r)&&(r[u]=l))}if(c!=="not_valid")for(const u of e.refiner(r,a))u.explanation=t.message,c="not_refined",yield[u,void 0];c==="valid"&&(yield[void 0,r])}let gt=class{constructor(e){const{type:t,schema:n,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,s?this.validator=(c,u)=>{const l=s(c,u);return Fs(l,u,this,c)}:this.validator=()=>[],o?this.refiner=(c,u)=>{const l=o(c,u);return Fs(l,u,this,c)}:this.refiner=()=>[]}assert(e,t){return di(e,this,t)}create(e,t){return v(e,this,t)}is(e){return hi(e,this)}mask(e,t){return _u(e,this,t)}validate(e,t={}){return vn(e,this,t)}};function di(r,e,t){const n=vn(r,e,{message:t});if(n[0])throw n[0]}function v(r,e,t){const n=vn(r,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function _u(r,e,t){const n=vn(r,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function hi(r,e){return!vn(r,e)[0]}function vn(r,e,t={}){const n=as(r,e,t),s=Au(n);return s[0]?[new Iu(s[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function Gt(r,e){return new gt({type:r,schema:null,validator:e})}function vu(){return Gt("any",()=>!0)}function P(r){return new gt({type:"array",schema:r,*entries(e){if(r&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,r]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${st(e)}`}})}function dt(){return Gt("boolean",r=>typeof r=="boolean")}function cs(r){return Gt("instance",e=>e instanceof r||`Expected a \`${r.name}\` instance, but received: ${st(e)}`)}function be(r){const e=st(r),t=typeof r;return new gt({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?r:null,validator(n){return n===r||`Expected the literal \`${e}\`, but received: ${st(n)}`}})}function Bu(){return Gt("never",()=>!1)}function T(r){return new gt({...r,validator:(e,t)=>e===null||r.validator(e,t),refiner:(e,t)=>e===null||r.refiner(e,t)})}function b(){return Gt("number",r=>typeof r=="number"&&!isNaN(r)||`Expected a number, but received: ${st(r)}`)}function H(r){return new gt({...r,validator:(e,t)=>e===void 0||r.validator(e,t),refiner:(e,t)=>e===void 0||r.refiner(e,t)})}function fi(r,e){return new gt({type:"record",schema:null,*entries(t){if(_n(t))for(const n in t){const s=t[n];yield[n,n,r],yield[n,s,e]}},validator(t){return Mn(t)||`Expected an object, but received: ${st(t)}`},coercer(t){return Mn(t)?{...t}:t}})}function E(){return Gt("string",r=>typeof r=="string"||`Expected a string, but received: ${st(r)}`)}function us(r){const e=Bu();return new gt({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(r.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],r[s]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${st(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function I(r){const e=Object.keys(r);return new gt({type:"type",schema:r,*entries(t){if(_n(t))for(const n of e)yield[n,t[n],r[n]]},validator(t){return Mn(t)||`Expected an object, but received: ${st(t)}`},coercer(t){return Mn(t)?{...t}:t}})}function Me(r){const e=r.map(t=>t.type).join(" | ");return new gt({type:"union",schema:null,coercer(t,n){for(const s of r){const[o,i]=s.validate(t,{coerce:!0,mask:n.mask});if(!o)return i}return t},validator(t,n){const s=[];for(const o of r){const[...i]=as(t,o,n),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${st(t)}`,...s]}})}function hn(){return Gt("unknown",()=>!0)}function Bn(r,e,t){return new gt({...r,coercer:(n,s)=>hi(n,e)?r.coercer(t(n,s),s):r.coercer(n,s)})}const pi=bo(Ea),Ru=pi.v4,Pu=function(r,e,t,n){if(typeof r!="string")throw new TypeError(r+" must be a string");n=n||{};const s=typeof n.version=="number"?n.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");const o={method:r};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof n.generator=="function"?n.generator:function(){return Ru()};o.id=i(o,n)}else s===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};var Tu=Pu;const Lu=pi.v4,Cu=Tu,Sn=function(r,e){if(!(this instanceof Sn))return new Sn(r,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return Lu()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=r};var Ou=Sn;Sn.prototype.request=function(r,e,t,n){const s=this;let o=null;const i=Array.isArray(r)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&r&&typeof r=="object"&&typeof e=="function")n=e,o=r;else{typeof t=="function"&&(n=t,t=void 0);const u=typeof n=="function";try{o=Cu(r,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(l){if(u)return n(l);throw l}if(!u)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(u){return n(u)}return this.callServer(c,function(u,l){s._parseResponse(u,l,n)}),o};Sn.prototype._parseResponse=function(r,e,t){if(r){t(r);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(n)){const s=function(i){return typeof i.error<"u"},o=function(i){return!s(i)};return t(null,n.filter(s),n.filter(o))}else return t(null,n.error,n.result);t(null,n)};const Uu=Mr(Ou);var gi={exports:{}};(function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,u,l){this.fn=c,this.context=u,this.once=l||!1}function o(c,u,l,d,p){if(typeof l!="function")throw new TypeError("The listener must be a function");var f=new s(l,d||c,p),y=t?t+u:u;return c._events[y]?c._events[y].fn?c._events[y]=[c._events[y],f]:c._events[y].push(f):(c._events[y]=f,c._eventsCount++),c}function i(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],l,d;if(this._eventsCount===0)return u;for(d in l=this._events)e.call(l,d)&&u.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(l)):u},a.prototype.listeners=function(u){var l=t?t+u:u,d=this._events[l];if(!d)return[];if(d.fn)return[d.fn];for(var p=0,f=d.length,y=new Array(f);p<f;p++)y[p]=d[p].fn;return y},a.prototype.listenerCount=function(u){var l=t?t+u:u,d=this._events[l];return d?d.fn?1:d.length:0},a.prototype.emit=function(u,l,d,p,f,y){var g=t?t+u:u;if(!this._events[g])return!1;var h=this._events[g],k=arguments.length,x,w;if(h.fn){switch(h.once&&this.removeListener(u,h.fn,void 0,!0),k){case 1:return h.fn.call(h.context),!0;case 2:return h.fn.call(h.context,l),!0;case 3:return h.fn.call(h.context,l,d),!0;case 4:return h.fn.call(h.context,l,d,p),!0;case 5:return h.fn.call(h.context,l,d,p,f),!0;case 6:return h.fn.call(h.context,l,d,p,f,y),!0}for(w=1,x=new Array(k-1);w<k;w++)x[w-1]=arguments[w];h.fn.apply(h.context,x)}else{var R=h.length,W;for(w=0;w<R;w++)switch(h[w].once&&this.removeListener(u,h[w].fn,void 0,!0),k){case 1:h[w].fn.call(h[w].context);break;case 2:h[w].fn.call(h[w].context,l);break;case 3:h[w].fn.call(h[w].context,l,d);break;case 4:h[w].fn.call(h[w].context,l,d,p);break;default:if(!x)for(W=1,x=new Array(k-1);W<k;W++)x[W-1]=arguments[W];h[w].fn.apply(h[w].context,x)}}return!0},a.prototype.on=function(u,l,d){return o(this,u,l,d,!1)},a.prototype.once=function(u,l,d){return o(this,u,l,d,!0)},a.prototype.removeListener=function(u,l,d,p){var f=t?t+u:u;if(!this._events[f])return this;if(!l)return i(this,f),this;var y=this._events[f];if(y.fn)y.fn===l&&(!p||y.once)&&(!d||y.context===d)&&i(this,f);else{for(var g=0,h=[],k=y.length;g<k;g++)(y[g].fn!==l||p&&!y[g].once||d&&y[g].context!==d)&&h.push(y[g]);h.length?this._events[f]=h.length===1?h[0]:h:i(this,f)}return this},a.prototype.removeAllListeners=function(u){var l;return u?(l=t?t+u:u,this._events[l]&&i(this,l)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a})(gi);var Nu=gi.exports;const yi=Mr(Nu);var zu=class extends yi{constructor(e,t,n){super();_e(this,"socket");this.socket=new window.WebSocket(e,n),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=s=>this.emit("message",s.data),this.socket.onerror=s=>this.emit("error",s),this.socket.onclose=s=>{this.emit("close",s.code,s.reason)}}send(e,t,n){const s=n||t;try{this.socket.send(e),s()}catch(o){s(o)}}close(e,t){this.socket.close(e,t)}addEventListener(e,t,n){this.socket.addEventListener(e,t,n)}};function Ku(r,e){return new zu(r,e)}var Wu=class{encode(r){return JSON.stringify(r)}decode(r){return JSON.parse(r)}},Fu=class extends yi{constructor(e,t="ws://localhost:8080",{autoconnect:n=!0,reconnect:s=!0,reconnect_interval:o=1e3,max_reconnects:i=5,...a}={},c,u){super();_e(this,"address");_e(this,"rpc_id");_e(this,"queue");_e(this,"options");_e(this,"autoconnect");_e(this,"ready");_e(this,"reconnect");_e(this,"reconnect_timer_id");_e(this,"reconnect_interval");_e(this,"max_reconnects");_e(this,"rest_options");_e(this,"current_reconnects");_e(this,"generate_request_id");_e(this,"socket");_e(this,"webSocketFactory");_e(this,"dataPack");this.webSocketFactory=e,this.queue={},this.rpc_id=0,this.address=t,this.autoconnect=n,this.ready=!1,this.reconnect=s,this.reconnect_timer_id=void 0,this.reconnect_interval=o,this.max_reconnects=i,this.rest_options=a,this.current_reconnects=0,this.generate_request_id=c||(()=>++this.rpc_id),u?this.dataPack=u:this.dataPack=new Wu,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(e,t,n,s){return!s&&typeof n=="object"&&(s=n,n=null),new Promise((o,i)=>{if(!this.ready)return i(new Error("socket not ready"));const a=this.generate_request_id(e,t),c={jsonrpc:"2.0",method:e,params:t||void 0,id:a};this.socket.send(this.dataPack.encode(c),s,u=>{if(u)return i(u);this.queue[a]={promise:[o,i]},n&&(this.queue[a].timeout=setTimeout(()=>{delete this.queue[a],i(new Error("reply timeout"))},n))})})}async login(e){const t=await this.call("rpc.login",e);if(!t)throw new Error("authentication failed");return t}async listMethods(){return await this.call("__listMethods")}notify(e,t){return new Promise((n,s)=>{if(!this.ready)return s(new Error("socket not ready"));const o={jsonrpc:"2.0",method:e,params:t};this.socket.send(this.dataPack.encode(o),i=>{if(i)return s(i);n()})})}async subscribe(e){typeof e=="string"&&(e=[e]);const t=await this.call("rpc.on",e);if(typeof e=="string"&&t[e]!=="ok")throw new Error("Failed subscribing to an event '"+e+"' with: "+t[e]);return t}async unsubscribe(e){typeof e=="string"&&(e=[e]);const t=await this.call("rpc.off",e);if(typeof e=="string"&&t[e]!=="ok")throw new Error("Failed unsubscribing from an event with: "+t);return t}close(e,t){this.socket.close(e||1e3,t)}setAutoReconnect(e){this.reconnect=e}setReconnectInterval(e){this.reconnect_interval=e}setMaxReconnects(e){this.max_reconnects=e}_connect(e,t){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(e,t),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:n})=>{n instanceof ArrayBuffer&&(n=M.from(n).toString());try{n=this.dataPack.decode(n)}catch{return}if(n.notification&&this.listeners(n.notification).length){if(!Object.keys(n.params).length)return this.emit(n.notification);const s=[n.notification];if(n.params.constructor===Object)s.push(n.params);else for(let o=0;o<n.params.length;o++)s.push(n.params[o]);return Promise.resolve().then(()=>{this.emit.apply(this,s)})}if(!this.queue[n.id])return n.method?Promise.resolve().then(()=>{this.emit(n.method,n==null?void 0:n.params)}):void 0;"error"in n=="result"in n&&this.queue[n.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[n.id].timeout&&clearTimeout(this.queue[n.id].timeout),n.error?this.queue[n.id].promise[1](n.error):this.queue[n.id].promise[0](n.result),delete this.queue[n.id]}),this.socket.addEventListener("error",n=>this.emit("error",n)),this.socket.addEventListener("close",({code:n,reason:s})=>{this.ready&&setTimeout(()=>this.emit("close",n,s),0),this.ready=!1,this.socket=void 0,n!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)&&(this.reconnect_timer_id=setTimeout(()=>this._connect(e,t),this.reconnect_interval)))})}};const On=BigInt(2**32-1),Ds=BigInt(32);function Du(r,e=!1){return e?{h:Number(r&On),l:Number(r>>Ds&On)}:{h:Number(r>>Ds&On)|0,l:Number(r&On)|0}}function qu(r,e=!1){let t=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){const{h:o,l:i}=Du(r[s],e);[t[s],n[s]]=[o,i]}return[t,n]}const Hu=(r,e,t)=>r<<t|e>>>32-t,Mu=(r,e,t)=>e<<t|r>>>32-t,$u=(r,e,t)=>e<<t-32|r>>>64-t,Vu=(r,e,t)=>r<<t-32|e>>>64-t,bi=[],mi=[],wi=[],ju=BigInt(0),pn=BigInt(1),Gu=BigInt(2),Yu=BigInt(7),Zu=BigInt(256),Ju=BigInt(113);for(let r=0,e=pn,t=1,n=0;r<24;r++){[t,n]=[n,(2*t+3*n)%5],bi.push(2*(5*n+t)),mi.push((r+1)*(r+2)/2%64);let s=ju;for(let o=0;o<7;o++)e=(e<<pn^(e>>Yu)*Ju)%Zu,e&Gu&&(s^=pn<<(pn<<BigInt(o))-pn);wi.push(s)}const[Xu,Qu]=qu(wi,!0),qs=(r,e,t)=>t>32?$u(r,e,t):Hu(r,e,t),Hs=(r,e,t)=>t>32?Vu(r,e,t):Mu(r,e,t);function el(r,e=24){const t=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let i=0;i<10;i++)t[i]=r[i]^r[i+10]^r[i+20]^r[i+30]^r[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,u=t[c],l=t[c+1],d=qs(u,l,1)^t[a],p=Hs(u,l,1)^t[a+1];for(let f=0;f<50;f+=10)r[i+f]^=d,r[i+f+1]^=p}let s=r[2],o=r[3];for(let i=0;i<24;i++){const a=mi[i],c=qs(s,o,a),u=Hs(s,o,a),l=bi[i];s=r[l],o=r[l+1],r[l]=c,r[l+1]=u}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)t[a]=r[i+a];for(let a=0;a<10;a++)r[i+a]^=~t[(a+2)%10]&t[(a+4)%10]}r[0]^=Xu[n],r[1]^=Qu[n]}t.fill(0)}class ls extends zo{constructor(e,t,n,s=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=n,this.enableXOF=s,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Ns(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Mc(this.state)}keccak(){zs||Ks(this.state32),el(this.state32,this.rounds),zs||Ks(this.state32),this.posOut=0,this.pos=0}update(e){Kn(this);const{blockLen:t,state:n}=this;e=Jr(e);const s=e.length;for(let o=0;o<s;){const i=Math.min(t-this.pos,s-o);for(let a=0;a<i;a++)n[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:s}=this;e[n]^=t,t&128&&n===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){Kn(this,!1),Zr(e),this.finish();const t=this.state,{blockLen:n}=this;for(let s=0,o=e.length;s<o;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,o-s);e.set(t.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Ns(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(No(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:s,rounds:o,enableXOF:i}=this;return e||(e=new ls(t,n,s,i,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=n,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}}const tl=(r,e,t)=>Ko(()=>new ls(e,r,t)),Ms=tl(1,136,256/8),nl=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Pt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Tt=new Uint32Array(64);class rl extends Ao{constructor(){super(64,32,8,!1),this.A=Pt[0]|0,this.B=Pt[1]|0,this.C=Pt[2]|0,this.D=Pt[3]|0,this.E=Pt[4]|0,this.F=Pt[5]|0,this.G=Pt[6]|0,this.H=Pt[7]|0}get(){const{A:e,B:t,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[e,t,n,s,o,i,a,c]}set(e,t,n,s,o,i,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)Tt[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const p=Tt[d-15],f=Tt[d-2],y=it(p,7)^it(p,18)^p>>>3,g=it(f,17)^it(f,19)^f>>>10;Tt[d]=g+Tt[d-7]+y+Tt[d-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:u,H:l}=this;for(let d=0;d<64;d++){const p=it(a,6)^it(a,11)^it(a,25),f=l+p+La(a,c,u)+nl[d]+Tt[d]|0,g=(it(n,2)^it(n,13)^it(n,22))+Ca(n,s,o)|0;l=u,u=c,c=a,a=i+f|0,i=o,o=s,s=n,n=f+g|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,o,i,a,c,u,l)}roundClean(){Tt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const sl=Io(()=>new rl);class ki extends So{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,va(e);const n=$r(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(n.length>s?e.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(e){return zn(this),this.iHash.update(e),this}digestInto(e){zn(this),Jn(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Si=(r,e,t)=>new ki(r,e).update(t).digest();Si.create=(r,e)=>new ki(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function $s(r){r.lowS!==void 0&&xt("lowS",r.lowS),r.prehash!==void 0&&xt("prehash",r.prehash)}function ol(r){const e=Gr(r);cn(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:il,hexToBytes:al}=pc,mt={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(r,e)=>{const{Err:t}=mt;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,s=Qt(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const o=n>127?Qt(s.length/2|128):"";return Qt(r)+o+s+e},decode(r,e){const{Err:t}=mt;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const s=e[n++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const u=e.subarray(n,n+c);if(u.length!==c)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const l of u)i=i<<8|l;if(n+=c,i<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+i);if(a.length!==i)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+i)}}},_int:{encode(r){const{Err:e}=mt;if(r<St)throw new e("integer: negative integers are not allowed");let t=Qt(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=mt;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return il(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=mt,s=typeof r=="string"?al(r):r;An(s);const{v:o,l:i}=n.decode(48,s);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:u,l}=n.decode(2,c);if(l.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(u)}},hexFromSig(r){const{_tlv:e,_int:t}=mt,n=e.encode(2,t.encode(r.r)),s=e.encode(2,t.encode(r.s)),o=n+s;return e.encode(48,o)}},St=BigInt(0),Be=BigInt(1);BigInt(2);const Vs=BigInt(3);BigInt(4);function cl(r){const e=ol(r),{Fp:t}=e,n=tr(e.n,e.nBitLength),s=e.toBytes||((g,h,k)=>{const x=h.toAffine();return Vt(Uint8Array.from([4]),t.toBytes(x.x),t.toBytes(x.y))}),o=e.fromBytes||(g=>{const h=g.subarray(1),k=t.fromBytes(h.subarray(0,t.BYTES)),x=t.fromBytes(h.subarray(t.BYTES,2*t.BYTES));return{x:k,y:x}});function i(g){const{a:h,b:k}=e,x=t.sqr(g),w=t.mul(x,g);return t.add(t.add(w,t.mul(g,h)),k)}if(!t.eql(t.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function a(g){return er(g,Be,e.n)}function c(g){const{allowedPrivateKeyLengths:h,nByteLength:k,wrapPrivateKey:x,n:w}=e;if(h&&typeof g!="bigint"){if(Mt(g)&&(g=$t(g)),typeof g!="string"||!h.includes(g.length))throw new Error("invalid private key");g=g.padStart(k*2,"0")}let R;try{R=typeof g=="bigint"?g:qt(Ie("private key",g,k))}catch{throw new Error("invalid private key, expected hex or "+k+" bytes, got "+typeof g)}return x&&(R=ye(R,w)),et("private key",R,Be,w),R}function u(g){if(!(g instanceof p))throw new Error("ProjectivePoint expected")}const l=kn((g,h)=>{const{px:k,py:x,pz:w}=g;if(t.eql(w,t.ONE))return{x:k,y:x};const R=g.is0();h==null&&(h=R?t.ONE:t.inv(w));const W=t.mul(k,h),F=t.mul(x,h),N=t.mul(w,h);if(R)return{x:t.ZERO,y:t.ZERO};if(!t.eql(N,t.ONE))throw new Error("invZ was invalid");return{x:W,y:F}}),d=kn(g=>{if(g.is0()){if(e.allowInfinityPoint&&!t.is0(g.py))return;throw new Error("bad point: ZERO")}const{x:h,y:k}=g.toAffine();if(!t.isValid(h)||!t.isValid(k))throw new Error("bad point: x or y not FE");const x=t.sqr(k),w=i(h);if(!t.eql(x,w))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class p{constructor(h,k,x){if(this.px=h,this.py=k,this.pz=x,h==null||!t.isValid(h))throw new Error("x required");if(k==null||!t.isValid(k))throw new Error("y required");if(x==null||!t.isValid(x))throw new Error("z required");Object.freeze(this)}static fromAffine(h){const{x:k,y:x}=h||{};if(!h||!t.isValid(k)||!t.isValid(x))throw new Error("invalid affine point");if(h instanceof p)throw new Error("projective point not allowed");const w=R=>t.eql(R,t.ZERO);return w(k)&&w(x)?p.ZERO:new p(k,x,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const k=t.invertBatch(h.map(x=>x.pz));return h.map((x,w)=>x.toAffine(k[w])).map(p.fromAffine)}static fromHex(h){const k=p.fromAffine(o(Ie("pointHex",h)));return k.assertValidity(),k}static fromPrivateKey(h){return p.BASE.multiply(c(h))}static msm(h,k){return Oo(p,n,h,k)}_setWindowSize(h){y.setWindowSize(this,h)}assertValidity(){d(this)}hasEvenY(){const{y:h}=this.toAffine();if(t.isOdd)return!t.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){u(h);const{px:k,py:x,pz:w}=this,{px:R,py:W,pz:F}=h,N=t.eql(t.mul(k,F),t.mul(R,w)),q=t.eql(t.mul(x,F),t.mul(W,w));return N&&q}negate(){return new p(this.px,t.neg(this.py),this.pz)}double(){const{a:h,b:k}=e,x=t.mul(k,Vs),{px:w,py:R,pz:W}=this;let F=t.ZERO,N=t.ZERO,q=t.ZERO,D=t.mul(w,w),ge=t.mul(R,R),re=t.mul(W,W),Q=t.mul(w,R);return Q=t.add(Q,Q),q=t.mul(w,W),q=t.add(q,q),F=t.mul(h,q),N=t.mul(x,re),N=t.add(F,N),F=t.sub(ge,N),N=t.add(ge,N),N=t.mul(F,N),F=t.mul(Q,F),q=t.mul(x,q),re=t.mul(h,re),Q=t.sub(D,re),Q=t.mul(h,Q),Q=t.add(Q,q),q=t.add(D,D),D=t.add(q,D),D=t.add(D,re),D=t.mul(D,Q),N=t.add(N,D),re=t.mul(R,W),re=t.add(re,re),D=t.mul(re,Q),F=t.sub(F,D),q=t.mul(re,ge),q=t.add(q,q),q=t.add(q,q),new p(F,N,q)}add(h){u(h);const{px:k,py:x,pz:w}=this,{px:R,py:W,pz:F}=h;let N=t.ZERO,q=t.ZERO,D=t.ZERO;const ge=e.a,re=t.mul(e.b,Vs);let Q=t.mul(k,R),xe=t.mul(x,W),L=t.mul(w,F),z=t.add(k,x),A=t.add(R,W);z=t.mul(z,A),A=t.add(Q,xe),z=t.sub(z,A),A=t.add(k,w);let S=t.add(R,F);return A=t.mul(A,S),S=t.add(Q,L),A=t.sub(A,S),S=t.add(x,w),N=t.add(W,F),S=t.mul(S,N),N=t.add(xe,L),S=t.sub(S,N),D=t.mul(ge,A),N=t.mul(re,L),D=t.add(N,D),N=t.sub(xe,D),D=t.add(xe,D),q=t.mul(N,D),xe=t.add(Q,Q),xe=t.add(xe,Q),L=t.mul(ge,L),A=t.mul(re,A),xe=t.add(xe,L),L=t.sub(Q,L),L=t.mul(ge,L),A=t.add(A,L),Q=t.mul(xe,A),q=t.add(q,Q),Q=t.mul(S,A),N=t.mul(z,N),N=t.sub(N,Q),Q=t.mul(z,xe),D=t.mul(S,D),D=t.add(D,Q),new p(N,q,D)}subtract(h){return this.add(h.negate())}is0(){return this.equals(p.ZERO)}wNAF(h){return y.wNAFCached(this,h,p.normalizeZ)}multiplyUnsafe(h){const{endo:k,n:x}=e;et("scalar",h,St,x);const w=p.ZERO;if(h===St)return w;if(this.is0()||h===Be)return this;if(!k||y.hasPrecomputes(this))return y.wNAFCachedUnsafe(this,h,p.normalizeZ);let{k1neg:R,k1:W,k2neg:F,k2:N}=k.splitScalar(h),q=w,D=w,ge=this;for(;W>St||N>St;)W&Be&&(q=q.add(ge)),N&Be&&(D=D.add(ge)),ge=ge.double(),W>>=Be,N>>=Be;return R&&(q=q.negate()),F&&(D=D.negate()),D=new p(t.mul(D.px,k.beta),D.py,D.pz),q.add(D)}multiply(h){const{endo:k,n:x}=e;et("scalar",h,Be,x);let w,R;if(k){const{k1neg:W,k1:F,k2neg:N,k2:q}=k.splitScalar(h);let{p:D,f:ge}=this.wNAF(F),{p:re,f:Q}=this.wNAF(q);D=y.constTimeNegate(W,D),re=y.constTimeNegate(N,re),re=new p(t.mul(re.px,k.beta),re.py,re.pz),w=D.add(re),R=ge.add(Q)}else{const{p:W,f:F}=this.wNAF(h);w=W,R=F}return p.normalizeZ([w,R])[0]}multiplyAndAddUnsafe(h,k,x){const w=p.BASE,R=(F,N)=>N===St||N===Be||!F.equals(w)?F.multiplyUnsafe(N):F.multiply(N),W=R(this,k).add(R(h,x));return W.is0()?void 0:W}toAffine(h){return l(this,h)}isTorsionFree(){const{h,isTorsionFree:k}=e;if(h===Be)return!0;if(k)return k(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:k}=e;return h===Be?this:k?k(p,this):this.multiplyUnsafe(e.h)}toRawBytes(h=!0){return xt("isCompressed",h),this.assertValidity(),s(p,this,h)}toHex(h=!0){return xt("isCompressed",h),$t(this.toRawBytes(h))}}p.BASE=new p(e.Gx,e.Gy,t.ONE),p.ZERO=new p(t.ZERO,t.ONE,t.ZERO);const f=e.nBitLength,y=Co(p,e.endo?Math.ceil(f/2):f);return{CURVE:e,ProjectivePoint:p,normPrivateKeyToScalar:c,weierstrassEquation:i,isWithinCurveOrder:a}}function ul(r){const e=Gr(r);return cn(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function ll(r){const e=ul(r),{Fp:t,n}=e,s=t.BYTES+1,o=2*t.BYTES+1;function i(L){return ye(L,n)}function a(L){return Ur(L,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:l,isWithinCurveOrder:d}=cl({...e,toBytes(L,z,A){const S=z.toAffine(),_=t.toBytes(S.x),C=Vt;return xt("isCompressed",A),A?C(Uint8Array.from([z.hasEvenY()?2:3]),_):C(Uint8Array.from([4]),_,t.toBytes(S.y))},fromBytes(L){const z=L.length,A=L[0],S=L.subarray(1);if(z===s&&(A===2||A===3)){const _=qt(S);if(!er(_,Be,t.ORDER))throw new Error("Point is not on curve");const C=l(_);let $;try{$=t.sqrt(C)}catch(ee){const j=ee instanceof Error?": "+ee.message:"";throw new Error("Point is not on curve"+j)}const V=($&Be)===Be;return(A&1)===1!==V&&($=t.neg($)),{x:_,y:$}}else if(z===o&&A===4){const _=t.fromBytes(S.subarray(0,t.BYTES)),C=t.fromBytes(S.subarray(t.BYTES,2*t.BYTES));return{x:_,y:C}}else{const _=s,C=o;throw new Error("invalid Point, expected length of "+_+", or uncompressed "+C+", got "+z)}}}),p=L=>$t(nn(L,e.nByteLength));function f(L){const z=n>>Be;return L>z}function y(L){return f(L)?i(-L):L}const g=(L,z,A)=>qt(L.slice(z,A));class h{constructor(z,A,S){this.r=z,this.s=A,this.recovery=S,this.assertValidity()}static fromCompact(z){const A=e.nByteLength;return z=Ie("compactSignature",z,A*2),new h(g(z,0,A),g(z,A,2*A))}static fromDER(z){const{r:A,s:S}=mt.toSig(Ie("DER",z));return new h(A,S)}assertValidity(){et("r",this.r,Be,n),et("s",this.s,Be,n)}addRecoveryBit(z){return new h(this.r,this.s,z)}recoverPublicKey(z){const{r:A,s:S,recovery:_}=this,C=F(Ie("msgHash",z));if(_==null||![0,1,2,3].includes(_))throw new Error("recovery id invalid");const $=_===2||_===3?A+e.n:A;if($>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const V=_&1?"03":"02",J=c.fromHex(V+p($)),ee=a($),j=i(-C*ee),ce=i(S*ee),le=c.BASE.multiplyAndAddUnsafe(J,j,ce);if(!le)throw new Error("point at infinify");return le.assertValidity(),le}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return tn(this.toDERHex())}toDERHex(){return mt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return tn(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const k={isValidPrivateKey(L){try{return u(L),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const L=Po(e.n);return Ac(e.randomBytes(L),e.n)},precompute(L=8,z=c.BASE){return z._setWindowSize(L),z.multiply(BigInt(3)),z}};function x(L,z=!0){return c.fromPrivateKey(L).toRawBytes(z)}function w(L){const z=Mt(L),A=typeof L=="string",S=(z||A)&&L.length;return z?S===s||S===o:A?S===2*s||S===2*o:L instanceof c}function R(L,z,A=!0){if(w(L))throw new Error("first arg must be private key");if(!w(z))throw new Error("second arg must be public key");return c.fromHex(z).multiply(u(L)).toRawBytes(A)}const W=e.bits2int||function(L){if(L.length>8192)throw new Error("input is too large");const z=qt(L),A=L.length*8-e.nBitLength;return A>0?z>>BigInt(A):z},F=e.bits2int_modN||function(L){return i(W(L))},N=jr(e.nBitLength);function q(L){return et("num < 2^"+e.nBitLength,L,St,N),nn(L,e.nByteLength)}function D(L,z,A=ge){if(["recovered","canonical"].some(Ee=>Ee in A))throw new Error("sign() legacy options not supported");const{hash:S,randomBytes:_}=e;let{lowS:C,prehash:$,extraEntropy:V}=A;C==null&&(C=!0),L=Ie("msgHash",L),$s(A),$&&(L=Ie("prehashed msgHash",S(L)));const J=F(L),ee=u(z),j=[q(ee),q(J)];if(V!=null&&V!==!1){const Ee=V===!0?_(t.BYTES):V;j.push(Ie("extraEntropy",Ee))}const ce=Vt(...j),le=J;function Ae(Ee){const Pe=W(Ee);if(!d(Pe))return;const ze=a(Pe),$e=c.BASE.multiply(Pe).toAffine(),qe=i($e.x);if(qe===St)return;const ot=i(ze*i(le+qe*ee));if(ot===St)return;let Et=($e.x===qe?0:2)|Number($e.y&Be),yt=ot;return C&&f(ot)&&(yt=y(ot),Et^=1),new h(qe,yt,Et)}return{seed:ce,k2sig:Ae}}const ge={lowS:e.lowS,prehash:!1},re={lowS:e.lowS,prehash:!1};function Q(L,z,A=ge){const{seed:S,k2sig:_}=D(L,z,A),C=e;return vo(C.hash.outputLen,C.nByteLength,C.hmac)(S,_)}c.BASE._setWindowSize(8);function xe(L,z,A,S=re){var Et;const _=L;z=Ie("msgHash",z),A=Ie("publicKey",A);const{lowS:C,prehash:$,format:V}=S;if($s(S),"strict"in S)throw new Error("options.strict was renamed to lowS");if(V!==void 0&&V!=="compact"&&V!=="der")throw new Error("format must be compact or der");const J=typeof _=="string"||Mt(_),ee=!J&&!V&&typeof _=="object"&&_!==null&&typeof _.r=="bigint"&&typeof _.s=="bigint";if(!J&&!ee)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let j,ce;try{if(ee&&(j=new h(_.r,_.s)),J){try{V!=="compact"&&(j=h.fromDER(_))}catch(yt){if(!(yt instanceof mt.Err))throw yt}!j&&V!=="der"&&(j=h.fromCompact(_))}ce=c.fromHex(A)}catch{return!1}if(!j||C&&j.hasHighS())return!1;$&&(z=e.hash(z));const{r:le,s:Ae}=j,Ee=F(z),Pe=a(Ae),ze=i(Ee*Pe),$e=i(le*Pe),qe=(Et=c.BASE.multiplyAndAddUnsafe(ce,ze,$e))==null?void 0:Et.toAffine();return qe?i(qe.x)===le:!1}return{CURVE:e,getPublicKey:x,getSharedSecret:R,sign:Q,verify:xe,ProjectivePoint:c,Signature:h,utils:k}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function dl(r){return{hash:r,hmac:(e,...t)=>Si(r,e,Pa(...t)),randomBytes:xo}}function hl(r,e){const t=n=>ll({...r,...dl(n)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ii=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),js=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),fl=BigInt(1),zr=BigInt(2),Gs=(r,e)=>(r+e/zr)/e;function pl(r){const e=Ii,t=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%e,l=u*u*r%e,d=ke(l,t,e)*l%e,p=ke(d,t,e)*l%e,f=ke(p,zr,e)*u%e,y=ke(f,s,e)*f%e,g=ke(y,o,e)*y%e,h=ke(g,a,e)*g%e,k=ke(h,c,e)*h%e,x=ke(k,a,e)*g%e,w=ke(x,t,e)*l%e,R=ke(w,i,e)*y%e,W=ke(R,n,e)*u%e,F=ke(W,zr,e);if(!Kr.eql(Kr.sqr(F),r))throw new Error("Cannot find square root");return F}const Kr=tr(Ii,void 0,void 0,{sqrt:pl}),or=hl({a:BigInt(0),b:BigInt(7),Fp:Kr,n:js,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=js,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-fl*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,i=BigInt("0x100000000000000000000000000000000"),a=Gs(o*r,e),c=Gs(-n*r,e);let u=ye(r-a*t-c*s,e),l=ye(-a*n-c*o,e);const d=u>i,p=l>i;if(d&&(u=e-u),p&&(l=e-l),u>i||l>i)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:d,k1:u,k2neg:p,k2:l}}}},sl);BigInt(0);or.ProjectivePoint;const gl=un.utils.randomPrivateKey,Ys=()=>{const r=un.utils.randomPrivateKey(),e=$n(r),t=new Uint8Array(64);return t.set(r),t.set(e,32),{publicKey:e,secretKey:t}},$n=un.getPublicKey;function Zs(r){try{return un.ExtendedPoint.fromHex(r),!0}catch{return!1}}const ds=(r,e)=>un.sign(r,e.slice(0,32)),yl=un.verify,Z=r=>M.isBuffer(r)?r:r instanceof Uint8Array?M.from(r.buffer,r.byteOffset,r.byteLength):M.from(r);class xi{constructor(e){Object.assign(this,e)}encode(){return M.from($o(Nn,this))}static decode(e){return Vo(Nn,this,e)}static decodeUnchecked(e){return Fo(Nn,this,e)}}class _h extends xi{constructor(e){if(super(e),this.enum="",Object.keys(e).length!==1)throw new Error("Enum can only take single value");Object.keys(e).map(t=>{this.enum=t})}}const Nn=new Map;var Ai;const bl=32,At=32;function ml(r){return r._bn!==void 0}let Js=1;class B extends xi{constructor(e){if(super({}),this._bn=void 0,ml(e))this._bn=e._bn;else{if(typeof e=="string"){const t=Oe.decode(e);if(t.length!=At)throw new Error("Invalid public key input");this._bn=new _s(t)}else this._bn=new _s(e);if(this._bn.byteLength()>At)throw new Error("Invalid public key input")}}static unique(){const e=new B(Js);return Js+=1,new B(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return Oe.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(M);if(e.length===At)return e;const t=M.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=M.concat([e.toBuffer(),M.from(t),n.toBuffer()]),o=Ws(s);return new B(o)}static createProgramAddressSync(e,t){let n=M.alloc(0);e.forEach(function(o){if(o.length>bl)throw new TypeError("Max seed length exceeded");n=M.concat([n,Z(o)])}),n=M.concat([n,t.toBuffer(),M.from("ProgramDerivedAddress")]);const s=Ws(n);if(Zs(s))throw new Error("Invalid seeds, address must fall off the curve");return new B(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const o=e.concat(M.from([n]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new B(e);return Zs(t.toBytes())}}Ai=B;B.default=new Ai("11111111111111111111111111111111");Nn.set(B,{kind:"struct",fields:[["_bn","u256"]]});class vh{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=Z(e);if(e.length!==64)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=Z(gl()),this._publicKey=Z($n(this._secretKey))}get publicKey(){return new B(this._publicKey)}get secretKey(){return M.concat([this._secretKey,this._publicKey],64)}}const Bh=new B("BPFLoader1111111111111111111111111111111111"),Ht=1232,hs=127,Vn=64;class Ei extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Ei.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class _i extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(_i.prototype,"name",{value:"TransactionExpiredTimeoutError"});class yn extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(yn.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class jn{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});const s=o=>{const i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const X=(r="publicKey")=>pe(32,r),wl=(r="signature")=>pe(64,r),Dt=(r="string")=>{const e=U([O("length"),O("lengthPadding"),pe(Nt(O(),-8),"chars")],r),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{const c={chars:M.from(o,"utf8")};return n(c,i,a)},s.alloc=o=>O().span+O().span+M.from(o,"utf8").length,s},kl=(r="authorized")=>U([X("staker"),X("withdrawer")],r),Sl=(r="lockup")=>U([Ze("unixTimestamp"),Ze("epoch"),X("custodian")],r),Il=(r="voteInit")=>U([X("nodePubkey"),X("authorizedVoter"),X("authorizedWithdrawer"),ne("commission")],r),xl=(r="voteAuthorizeWithSeedArgs")=>U([O("voteAuthorizationType"),X("currentAuthorityDerivedKeyOwnerPubkey"),Dt("currentAuthorityDerivedKeySeed"),X("newAuthorized")],r);function vi(r,e){const t=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(e[s.property]);if("count"in s&&"elementLayout"in s){const o=e[s.property];if(Array.isArray(o))return o.length*t(s.elementLayout)}else if("fields"in s)return vi({layout:s},e[s.property]);return 0};let n=0;return r.layout.fields.forEach(s=>{n+=t(s)}),n}function je(r){let e=0,t=0;for(;;){let n=r.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function Je(r,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){r.push(n);break}else n|=128,r.push(n)}}function se(r,e){if(!r)throw new Error(e||"Assertion failed")}class ir{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=i=>{const a=i.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new ir(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];se(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{se(t.length>0,"Expected at least one writable signer key");const[c]=t[0];se(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new B(c)),...n.map(([c])=>new B(c)),...s.map(([c])=>new B(c)),...o.map(([c])=>new B(c))];return[i,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new B(o),c=e.findIndex(u=>u.equals(a));c>=0&&(se(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(o))}return[n,s]}}const Bi="Reached end of buffer unexpectedly";function ct(r){if(r.length===0)throw new Error(Bi);return r.shift()}function Ge(r,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>r.length:t>=r.length)throw new Error(Bi);return r.splice(...e)}class ht{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new B(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:Oe.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new jn(this.staticAccountKeys)}static compile(e){const t=ir.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),i=new jn(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:Oe.encode(a.data)}));return new ht({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Je(t,e);const n=this.instructions.map(d=>{const{accounts:p,programIdIndex:f}=d,y=Array.from(Oe.decode(d.data));let g=[];Je(g,p.length);let h=[];return Je(h,y.length),{programIdIndex:f,keyIndicesCount:M.from(g),keyIndices:p,dataLength:M.from(h),data:y}});let s=[];Je(s,n.length);let o=M.alloc(Ht);M.from(s).copy(o);let i=s.length;n.forEach(d=>{const f=U([ne("programIdIndex"),pe(d.keyIndicesCount.length,"keyIndicesCount"),Ne(ne("keyIndex"),d.keyIndices.length,"keyIndices"),pe(d.dataLength.length,"dataLength"),Ne(ne("userdatum"),d.data.length,"data")]).encode(d,o,i);i+=f}),o=o.slice(0,i);const a=U([pe(1,"numRequiredSignatures"),pe(1,"numReadonlySignedAccounts"),pe(1,"numReadonlyUnsignedAccounts"),pe(t.length,"keyCount"),Ne(X("key"),e,"keys"),X("recentBlockhash")]),c={numRequiredSignatures:M.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:M.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:M.from([this.header.numReadonlyUnsignedAccounts]),keyCount:M.from(t),keys:this.accountKeys.map(d=>Z(d.toBytes())),recentBlockhash:Oe.decode(this.recentBlockhash)};let u=M.alloc(2048);const l=a.encode(c,u);return o.copy(u,l),u.slice(0,l+o.length)}static from(e){let t=[...e];const n=ct(t);if(n!==(n&hs))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=ct(t),o=ct(t),i=je(t);let a=[];for(let p=0;p<i;p++){const f=Ge(t,0,At);a.push(new B(M.from(f)))}const c=Ge(t,0,At),u=je(t);let l=[];for(let p=0;p<u;p++){const f=ct(t),y=je(t),g=Ge(t,0,y),h=je(t),k=Ge(t,0,h),x=Oe.encode(M.from(k));l.push({programIdIndex:f,accounts:g,data:x})}const d={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:Oe.encode(M.from(c)),accountKeys:a,instructions:l};return new ht(d)}}class sn{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new jn(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){const s=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(o=>o.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const o of n.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(const o of n.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=ir.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const l of o){const d=t.extractTableLookup(l);if(d!==void 0){const[p,{writable:f,readonly:y}]=d;n.push(p),s.writable.push(...f),s.readonly.push(...y)}}const[i,a]=t.getMessageComponents(),u=new jn(a,s).compileInstructions(e.instructions);return new sn({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:u,addressTableLookups:n})}serialize(){const e=Array();Je(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Je(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Je(o,this.addressTableLookups.length);const i=U([ne("prefix"),U([ne("numRequiredSignatures"),ne("numReadonlySignedAccounts"),ne("numReadonlyUnsignedAccounts")],"header"),pe(e.length,"staticAccountKeysLength"),Ne(X(),this.staticAccountKeys.length,"staticAccountKeys"),X("recentBlockhash"),pe(n.length,"instructionsLength"),pe(t.length,"serializedInstructions"),pe(o.length,"addressTableLookupsLength"),pe(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(Ht),u=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(l=>l.toBytes()),recentBlockhash:Oe.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},a);return a.slice(0,u)}serializeInstructions(){let e=0;const t=new Uint8Array(Ht);for(const n of this.compiledInstructions){const s=Array();Je(s,n.accountKeyIndexes.length);const o=Array();Je(o,n.data.length);const i=U([ne("programIdIndex"),pe(s.length,"encodedAccountKeyIndexesLength"),Ne(ne(),n.accountKeyIndexes.length,"accountKeyIndexes"),pe(o.length,"encodedDataLength"),pe(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Ht);for(const n of this.addressTableLookups){const s=Array();Je(s,n.writableIndexes.length);const o=Array();Je(o,n.readonlyIndexes.length);const i=U([X("accountKey"),pe(s.length,"encodedWritableIndexesLength"),Ne(ne(),n.writableIndexes.length,"writableIndexes"),pe(o.length,"encodedReadonlyIndexesLength"),Ne(ne(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=ct(t),s=n&hs;se(n!==s,"Expected versioned message but received legacy message");const o=s;se(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:ct(t),numReadonlySignedAccounts:ct(t),numReadonlyUnsignedAccounts:ct(t)},a=[],c=je(t);for(let y=0;y<c;y++)a.push(new B(Ge(t,0,At)));const u=Oe.encode(Ge(t,0,At)),l=je(t),d=[];for(let y=0;y<l;y++){const g=ct(t),h=je(t),k=Ge(t,0,h),x=je(t),w=new Uint8Array(Ge(t,0,x));d.push({programIdIndex:g,accountKeyIndexes:k,data:w})}const p=je(t),f=[];for(let y=0;y<p;y++){const g=new B(Ge(t,0,At)),h=je(t),k=Ge(t,0,h),x=je(t),w=Ge(t,0,x);f.push({accountKey:g,writableIndexes:k,readonlyIndexes:w})}return new sn({header:i,staticAccountKeys:a,recentBlockhash:u,compiledInstructions:d,addressTableLookups:f})}}const Ri={deserializeMessageVersion(r){const e=r[0],t=e&hs;return t===e?"legacy":t},deserialize:r=>{const e=Ri.deserializeMessageVersion(r);if(e==="legacy")return ht.from(r);if(e===0)return sn.deserialize(r);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let Lt=function(r){return r[r.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",r[r.PROCESSED=1]="PROCESSED",r[r.TIMED_OUT=2]="TIMED_OUT",r[r.NONCE_INVALID=3]="NONCE_INVALID",r}({});const Al=M.alloc(Vn).fill(0);class he{constructor(e){this.keys=void 0,this.programId=void 0,this.data=M.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class ae{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new he(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let g=0;g<t.length;g++)if(t[g].programId===void 0)throw new Error(`Transaction instruction index ${g} has undefined program id`);const s=[],o=[];t.forEach(g=>{g.keys.forEach(k=>{o.push({...k})});const h=g.programId.toString();s.includes(h)||s.push(h)}),s.forEach(g=>{o.push({pubkey:new B(g),isSigner:!1,isWritable:!1})});const i=[];o.forEach(g=>{const h=g.pubkey.toString(),k=i.findIndex(x=>x.pubkey.toString()===h);k>-1?(i[k].isWritable=i[k].isWritable||g.isWritable,i[k].isSigner=i[k].isSigner||g.isSigner):i.push(g)}),i.sort(function(g,h){if(g.isSigner!==h.isSigner)return g.isSigner?-1:1;if(g.isWritable!==h.isWritable)return g.isWritable?-1:1;const k={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return g.pubkey.toBase58().localeCompare(h.pubkey.toBase58(),"en",k)});const a=i.findIndex(g=>g.pubkey.equals(n));if(a>-1){const[g]=i.splice(a,1);g.isSigner=!0,g.isWritable=!0,i.unshift(g)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const g of this.signatures){const h=i.findIndex(k=>k.pubkey.equals(g.publicKey));if(h>-1)i[h].isSigner||(i[h].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${g.publicKey.toString()}`)}let c=0,u=0,l=0;const d=[],p=[];i.forEach(({pubkey:g,isSigner:h,isWritable:k})=>{h?(d.push(g.toString()),c+=1,k||(u+=1)):(p.push(g.toString()),k||(l+=1))});const f=d.concat(p),y=t.map(g=>{const{data:h,programId:k}=g;return{programIdIndex:f.indexOf(k.toString()),accounts:g.keys.map(x=>f.indexOf(x.pubkey.toString())),data:Oe.encode(h)}});return y.forEach(g=>{se(g.programIdIndex>=0),g.accounts.forEach(h=>se(h>=0))}),new ht({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:f,recentBlockhash:e,instructions:y})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const o=ds(n,s.secretKey);this._addSignature(s.publicKey,Z(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){se(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=M.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const n={};for(const{signature:s,publicKey:o}of this.signatures)s===null?t&&(n.missing||(n.missing=[])).push(o):yl(s,e,o.toBytes())||(n.invalid||(n.invalid=[])).push(o);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n){const o=this._getMessageSignednessErrors(s,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];Je(n,t.length);const s=n.length+t.length*64+e.length,o=M.alloc(s);return se(t.length<256),M.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(se(i.length===64,"signature has invalid length"),M.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),se(o.length<=Ht,`Transaction too large: ${o.length} > ${Ht}`),o}get keys(){return se(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return se(this.instructions.length===1),this.instructions[0].programId}get data(){return se(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=je(t);let s=[];for(let o=0;o<n;o++){const i=Ge(t,0,Vn);s.push(Oe.encode(M.from(i)))}return ae.populate(ht.from(t),s)}static populate(e,t=[]){const n=new ae;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{const i={signature:s==Oe.encode(Al)?null:Oe.decode(s),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(s=>{const o=s.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new he({keys:o,programId:e.accountKeys[s.programIdIndex],data:Oe.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}class Pi{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:n,compiledInstructions:s,recentBlockhash:o}=e,{numRequiredSignatures:i,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=n,u=i-a;se(u>0,"Message header is invalid");const l=e.staticAccountKeys.length-i-c;se(l>=0,"Message header is invalid");const d=e.getAccountKeys(t),p=d.get(0);if(p===void 0)throw new Error("Failed to decompile message because no account keys were found");const f=[];for(const y of s){const g=[];for(const k of y.accountKeyIndexes){const x=d.get(k);if(x===void 0)throw new Error(`Failed to find key for account key index ${k}`);const w=k<i;let R;w?R=k<u:k<d.staticAccountKeys.length?R=k-i<l:R=k-d.staticAccountKeys.length<d.accountKeysFromLookups.writable.length,g.push({pubkey:x,isSigner:k<n.numRequiredSignatures,isWritable:R})}const h=d.get(y.programIdIndex);if(h===void 0)throw new Error(`Failed to find program id for program id index ${y.programIdIndex}`);f.push(new he({programId:h,data:Z(y.data),keys:g}))}return new Pi({payerKey:p,instructions:f,recentBlockhash:o})}compileToLegacyMessage(){return ht.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return sn.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class Ti{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)se(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const n=[];for(let s=0;s<e.header.numRequiredSignatures;s++)n.push(new Uint8Array(Vn));this.signatures=n}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Je(t,this.signatures.length);const n=U([pe(t.length,"encodedSignaturesLength"),Ne(wl(),this.signatures.length,"signatures"),pe(e.length,"serializedMessage")]),s=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},s);return s.slice(0,o)}static deserialize(e){let t=[...e];const n=[],s=je(t);for(let i=0;i<s;i++)n.push(new Uint8Array(Ge(t,0,Vn)));const o=Ri.deserialize(new Uint8Array(t));return new Ti(o,n)}sign(e){const t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of e){const o=n.findIndex(i=>i.equals(s.publicKey));se(o>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[o]=ds(t,s.secretKey)}}addSignature(e,t){se(t.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));se(s>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}}const El=160,_l=64,vl=El/_l,Li=1e3/vl,wt=new B("SysvarC1ock11111111111111111111111111111111"),Rh=new B("SysvarEpochSchedu1e111111111111111111111111"),Ph=new B("Sysvar1nstructions1111111111111111111111111"),Er=new B("SysvarRecentB1ockHashes11111111111111111111"),In=new B("SysvarRent111111111111111111111111111111111"),Th=new B("SysvarRewards111111111111111111111111111111"),Lh=new B("SysvarS1otHashes111111111111111111111111111"),Ch=new B("SysvarS1otHistory11111111111111111111111111"),_r=new B("SysvarStakeHistory1111111111111111111111111");class Gn extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:s}){const o=s?`Logs: 
${JSON.stringify(s.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let a;switch(e){case"send":a=`Transaction ${t} resulted in an error. 
${n}. `+o+i;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+o+i;break;default:a=`Unknown action '${(c=>c)(e)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=s||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(s=>{if(s&&s.meta&&s.meta.logMessages){const o=s.meta.logMessages;this.transactionLogs=o,t(o)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}}const Oh={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class K extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}async function Xs(r,e,t,n){const s=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},o=await r.sendTransaction(e,t,s);let i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(await r.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,signature:o,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){const{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;i=(await r.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:o},n&&n.commitment)).value}else(n==null?void 0:n.abortSignal)!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),i=(await r.confirmTransaction(o,n&&n.commitment)).value;if(i.err)throw o!=null?new Gn({action:"send",signature:o,transactionMessage:`Status: (${JSON.stringify(i)})`}):new Error(`Transaction ${o} failed (${JSON.stringify(i)})`);return o}function Ft(r){return new Promise(e=>setTimeout(e,r))}function te(r,e){const t=r.layout.span>=0?r.layout.span:vi(r,e),n=M.alloc(t),s=Object.assign({instruction:r.index},e);return r.layout.encode(s,n),n}function ie(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.instruction!==r.index)throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${r.index}`);return t}const Bl=Te("lamportsPerSignature"),Ci=U([O("version"),O("state"),X("authorizedPubkey"),X("nonce"),U([Bl],"feeCalculator")]),Qs=Ci.span;class fs{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Ci.decode(Z(e),0);return new fs({authorizedPubkey:new B(t.authorizedPubkey),nonce:new B(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const Rl=r=>{const e=r.decode.bind(r),t=r.encode.bind(r);return{decode:e,encode:t}},Pl=r=>e=>{const t=pe(r,e),{encode:n,decode:s}=Rl(t),o=t;return o.decode=(i,a)=>{const c=s(i,a);return mu(M.from(c))},o.encode=(i,a,c)=>{const u=li(i,r);return n(u,a,c)},o},on=Pl(8);class Uh{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=O("instruction").decode(e.data);let s;for(const[o,i]of Object.entries(fe))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a SystemInstruction");return s}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:n,programId:s}=ie(fe.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:n,programId:new B(s)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=ie(fe.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:n,programId:s}=ie(fe.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:n,programId:new B(s)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=ie(fe.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,space:s,programId:o}=ie(fe.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new B(t),seed:n,space:s,programId:new B(o)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=ie(fe.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new B(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,programId:s}=ie(fe.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new B(t),seed:n,programId:new B(s)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:n,lamports:s,space:o,programId:i}=ie(fe.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new B(t),seed:n,lamports:s,space:o,programId:new B(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=ie(fe.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new B(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ie(fe.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=ie(fe.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=ie(fe.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new B(t)}}static checkProgramId(e){if(!e.equals(Ue.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const fe=Object.freeze({Create:{index:0,layout:U([O("instruction"),Ze("lamports"),Ze("space"),X("programId")])},Assign:{index:1,layout:U([O("instruction"),X("programId")])},Transfer:{index:2,layout:U([O("instruction"),on("lamports")])},CreateWithSeed:{index:3,layout:U([O("instruction"),X("base"),Dt("seed"),Ze("lamports"),Ze("space"),X("programId")])},AdvanceNonceAccount:{index:4,layout:U([O("instruction")])},WithdrawNonceAccount:{index:5,layout:U([O("instruction"),Ze("lamports")])},InitializeNonceAccount:{index:6,layout:U([O("instruction"),X("authorized")])},AuthorizeNonceAccount:{index:7,layout:U([O("instruction"),X("authorized")])},Allocate:{index:8,layout:U([O("instruction"),Ze("space")])},AllocateWithSeed:{index:9,layout:U([O("instruction"),X("base"),Dt("seed"),Ze("space"),X("programId")])},AssignWithSeed:{index:10,layout:U([O("instruction"),X("base"),Dt("seed"),X("programId")])},TransferWithSeed:{index:11,layout:U([O("instruction"),on("lamports"),Dt("seed"),X("programId")])},UpgradeNonceAccount:{index:12,layout:U([O("instruction")])}});class Ue{constructor(){}static createAccount(e){const t=fe.Create,n=te(t,{lamports:e.lamports,space:e.space,programId:Z(e.programId.toBuffer())});return new he({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){const s=fe.TransferWithSeed;t=te(s,{lamports:BigInt(e.lamports),seed:e.seed,programId:Z(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=fe.Transfer;t=te(s,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new he({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){const s=fe.AssignWithSeed;t=te(s,{base:Z(e.basePubkey.toBuffer()),seed:e.seed,programId:Z(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=fe.Assign;t=te(s,{programId:Z(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new he({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=fe.CreateWithSeed,n=te(t,{base:Z(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:Z(e.programId.toBuffer())});let s=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||s.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new he({keys:s,programId:this.programId,data:n})}static createNonceAccount(e){const t=new ae;"basePubkey"in e&&"seed"in e?t.add(Ue.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Qs,programId:this.programId})):t.add(Ue.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Qs,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){const t=fe.InitializeNonceAccount,n=te(t,{authorized:Z(e.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Er,isSigner:!1,isWritable:!1},{pubkey:In,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new he(s)}static nonceAdvance(e){const t=fe.AdvanceNonceAccount,n=te(t),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Er,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new he(s)}static nonceWithdraw(e){const t=fe.WithdrawNonceAccount,n=te(t,{lamports:e.lamports});return new he({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Er,isSigner:!1,isWritable:!1},{pubkey:In,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){const t=fe.AuthorizeNonceAccount,n=te(t,{authorized:Z(e.newAuthorizedPubkey.toBuffer())});return new he({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){const s=fe.AllocateWithSeed;t=te(s,{base:Z(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:Z(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=fe.Allocate;t=te(s,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new he({keys:n,programId:this.programId,data:t})}}Ue.programId=new B("11111111111111111111111111111111");const Tl=Ht-300;class an{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/an.chunkSize)+1+1)}static async load(e,t,n,s,o){{const d=await e.getMinimumBalanceForRentExemption(o.length),p=await e.getAccountInfo(n.publicKey,"confirmed");let f=null;if(p!==null){if(p.executable)return console.error("Program load failed, account is already executable"),!1;p.data.length!==o.length&&(f=f||new ae,f.add(Ue.allocate({accountPubkey:n.publicKey,space:o.length}))),p.owner.equals(s)||(f=f||new ae,f.add(Ue.assign({accountPubkey:n.publicKey,programId:s}))),p.lamports<d&&(f=f||new ae,f.add(Ue.transfer({fromPubkey:t.publicKey,toPubkey:n.publicKey,lamports:d-p.lamports})))}else f=new ae().add(Ue.createAccount({fromPubkey:t.publicKey,newAccountPubkey:n.publicKey,lamports:d>0?d:1,space:o.length,programId:s}));f!==null&&await Xs(e,f,[t,n],{commitment:"confirmed"})}const i=U([O("instruction"),O("offset"),O("bytesLength"),O("bytesLengthPadding"),Ne(ne("byte"),Nt(O(),-8),"bytes")]),a=an.chunkSize;let c=0,u=o,l=[];for(;u.length>0;){const d=u.slice(0,a),p=M.alloc(a+16);i.encode({instruction:0,offset:c,bytes:d,bytesLength:0,bytesLengthPadding:0},p);const f=new ae().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:s,data:p});l.push(Xs(e,f,[t,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await Ft(1e3/4),c+=a,u=u.slice(a)}await Promise.all(l);{const d=U([O("instruction")]),p=M.alloc(d.span);d.encode({instruction:1},p);const f=new ae().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:In,isSigner:!1,isWritable:!1}],programId:s,data:p}),y="processed",g=await e.sendTransaction(f,[t,n],{preflightCommitment:y}),{context:h,value:k}=await e.confirmTransaction({signature:g,lastValidBlockHeight:f.lastValidBlockHeight,blockhash:f.recentBlockhash},y);if(k.err)throw new Error(`Transaction ${g} failed (${JSON.stringify(k)})`);for(;;){try{if(await e.getSlot({commitment:y})>h.slot)break}catch{}await new Promise(x=>setTimeout(x,Math.round(Li/2)))}}return!0}}an.chunkSize=Tl;const Nh=new B("BPFLoader2111111111111111111111111111111111");class zh{static getMinNumSignatures(e){return an.getMinNumSignatures(e)}static load(e,t,n,s,o){return an.load(e,t,n,o,s)}}function Ll(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var vr,eo;function Cl(){if(eo)return vr;eo=1;var r=Object.prototype.toString,e=Object.keys||function(n){var s=[];for(var o in n)s.push(o);return s};function t(n,s){var o,i,a,c,u,l,d;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return t(n.toJSON(),s);if(d=r.call(n),d==="[object Array]"){for(a="[",i=n.length-1,o=0;o<i;o++)a+=t(n[o],!0)+",";return i>-1&&(a+=t(n[o],!0)),a+"]"}else if(d==="[object Object]"){for(c=e(n).sort(),i=c.length,a="",o=0;o<i;)u=c[o],l=t(n[u],!1),l!==void 0&&(a&&(a+=","),a+=JSON.stringify(u)+":"+l),o++;return"{"+a+"}"}else return JSON.stringify(n);case"function":case"undefined":return s?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}return vr=function(n){var s=t(n,!1);if(s!==void 0)return""+s},vr}var Ol=Cl(),to=Ll(Ol);const gn=32;function Br(r){let e=0;for(;r>1;)r/=2,e++;return e}function Ul(r){return r===0?1:(r--,r|=r>>1,r|=r>>2,r|=r>>4,r|=r>>8,r|=r>>16,r|=r>>32,r+1)}class Nl{constructor(e,t,n,s,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Br(Ul(e+gn+1))-Br(gn)-1,n=this.getSlotsInEpoch(t),s=e-(n-gn);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[s,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*gn:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Br(gn)):this.slotsPerEpoch}}var zl=globalThis.fetch;class Kl extends Fu{constructor(e,t,n){const s=o=>{const i=Ku(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function Wl(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==r.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${r.index}`);return t}const no=56;class ro{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=Wl(Fl,e),n=e.length-no;se(n>=0,"lookup table is invalid"),se(n%32===0,"lookup table is invalid");const s=n/32,{addresses:o}=U([Ne(X(),s,"addresses")]).decode(e.slice(no));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new B(t.authority[0]):void 0,addresses:o.map(i=>new B(i))}}}const Fl={index:1,layout:U([O("typeIndex"),on("deactivationSlot"),Te("lastExtendedSlot"),ne("lastExtendedStartIndex"),ne(),Ne(X(),Nt(ne(),-1),"authority")])},Dl=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function ql(r){const e=r.match(Dl);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${r}\``);const[t,n,s,o]=e,i=r.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}const we=Bn(cs(B),E(),r=>new B(r)),Oi=us([E(),be("base64")]),ps=Bn(cs(M),Oi,r=>M.from(r[0],"base64")),Hl=30*1e3;function Ml(r){if(/^https?:/.test(r)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return r}function de(r){let e,t;if(typeof r=="string")e=r;else if(r){const{commitment:n,...s}=r;e=n,t=s}return{commitment:e,config:t}}function so(r){return r.map(e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e)}function Ui(r){return Me([I({jsonrpc:be("2.0"),id:E(),result:r}),I({jsonrpc:be("2.0"),id:E(),error:I({code:hn(),message:E(),data:H(vu())})})])}const $l=Ui(hn());function Y(r){return Bn(Ui(r),$l,e=>"error"in e?e:{...e,result:v(e.result,r)})}function Se(r){return Y(I({context:I({slot:b()}),value:r}))}function ar(r){return I({context:I({slot:b()}),value:r})}function Rr(r,e){return r===0?new sn({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new B(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:Oe.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new ht(e)}const Vl=I({foundation:b(),foundationTerm:b(),initial:b(),taper:b(),terminal:b()}),jl=Y(P(T(I({epoch:b(),effectiveSlot:b(),amount:b(),postBalance:b(),commission:H(T(b()))})))),Gl=P(I({slot:b(),prioritizationFee:b()})),Yl=I({total:b(),validator:b(),foundation:b(),epoch:b()}),Zl=I({epoch:b(),slotIndex:b(),slotsInEpoch:b(),absoluteSlot:b(),blockHeight:H(b()),transactionCount:H(b())}),Jl=I({slotsPerEpoch:b(),leaderScheduleSlotOffset:b(),warmup:dt(),firstNormalEpoch:b(),firstNormalSlot:b()}),Xl=fi(E(),P(b())),Yt=T(Me([I({}),E()])),Ql=I({err:Yt}),ed=be("receivedSignature"),td=I({"solana-core":E(),"feature-set":H(b())}),nd=I({program:E(),programId:we,parsed:hn()}),rd=I({programId:we,accounts:P(we),data:E()}),oo=Se(I({err:T(Me([I({}),E()])),logs:T(P(E())),accounts:H(T(P(T(I({executable:dt(),owner:E(),lamports:b(),data:P(E()),rentEpoch:H(b())}))))),unitsConsumed:H(b()),returnData:H(T(I({programId:E(),data:us([E(),be("base64")])}))),innerInstructions:H(T(P(I({index:b(),instructions:P(Me([nd,rd]))}))))})),sd=Se(I({byIdentity:fi(E(),P(b())),range:I({firstSlot:b(),lastSlot:b()})}));function od(r,e,t,n,s,o){const i=t||zl;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(l,d)=>{const p=await new Promise((f,y)=>{try{n(l,d,(g,h)=>f([g,h]))}catch(g){y(g)}});return await i(...p)}),new Uu(async(l,d)=>{const p={method:"POST",body:l,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},ih)};try{let f=5,y,g=500;for(;c?y=await c(r,p):y=await i(r,p),!(y.status!==429||s===!0||(f-=1,f===0));)console.error(`Server responded with ${y.status} ${y.statusText}.  Retrying after ${g}ms delay...`),await Ft(g),g*=2;const h=await y.text();y.ok?d(null,h):d(new Error(`${y.status} ${y.statusText}: ${h}`))}catch(f){f instanceof Error&&d(f)}},{})}function id(r){return(e,t)=>new Promise((n,s)=>{r.request(e,t,(o,i)=>{if(o){s(o);return}n(i)})})}function ad(r){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(o=>r.request(o.methodName,o.args));r.request(s,(o,i)=>{if(o){n(o);return}t(i)})})}const cd=Y(Vl),ud=Y(Yl),ld=Y(Gl),dd=Y(Zl),hd=Y(Jl),fd=Y(Xl),pd=Y(b()),gd=Se(I({total:b(),circulating:b(),nonCirculating:b(),nonCirculatingAccounts:P(we)})),Wr=I({amount:E(),uiAmount:T(b()),decimals:b(),uiAmountString:H(E())}),yd=Se(P(I({address:we,amount:E(),uiAmount:T(b()),decimals:b(),uiAmountString:H(E())}))),bd=Se(P(I({pubkey:we,account:I({executable:dt(),owner:we,lamports:b(),data:ps,rentEpoch:b()})}))),Fr=I({program:E(),parsed:hn(),space:b()}),md=Se(P(I({pubkey:we,account:I({executable:dt(),owner:we,lamports:b(),data:Fr,rentEpoch:b()})}))),wd=Se(P(I({lamports:b(),address:we}))),xn=I({executable:dt(),owner:we,lamports:b(),data:ps,rentEpoch:b()}),kd=I({pubkey:we,account:xn}),Sd=Bn(Me([cs(M),Fr]),Me([Oi,Fr]),r=>Array.isArray(r)?v(r,ps):r),Dr=I({executable:dt(),owner:we,lamports:b(),data:Sd,rentEpoch:b()}),Id=I({pubkey:we,account:Dr}),xd=I({state:Me([be("active"),be("inactive"),be("activating"),be("deactivating")]),active:b(),inactive:b()}),Ad=Y(P(I({signature:E(),slot:b(),err:Yt,memo:T(E()),blockTime:H(T(b()))}))),Ed=Y(P(I({signature:E(),slot:b(),err:Yt,memo:T(E()),blockTime:H(T(b()))}))),_d=I({subscription:b(),result:ar(xn)}),vd=I({pubkey:we,account:xn}),Bd=I({subscription:b(),result:ar(vd)}),Rd=I({parent:b(),slot:b(),root:b()}),Pd=I({subscription:b(),result:Rd}),Td=Me([I({type:Me([be("firstShredReceived"),be("completed"),be("optimisticConfirmation"),be("root")]),slot:b(),timestamp:b()}),I({type:be("createdBank"),parent:b(),slot:b(),timestamp:b()}),I({type:be("frozen"),slot:b(),timestamp:b(),stats:I({numTransactionEntries:b(),numSuccessfulTransactions:b(),numFailedTransactions:b(),maxTransactionsPerEntry:b()})}),I({type:be("dead"),slot:b(),timestamp:b(),err:E()})]),Ld=I({subscription:b(),result:Td}),Cd=I({subscription:b(),result:ar(Me([Ql,ed]))}),Od=I({subscription:b(),result:b()}),Ud=I({pubkey:E(),gossip:T(E()),tpu:T(E()),rpc:T(E()),version:T(E())}),io=I({votePubkey:E(),nodePubkey:E(),activatedStake:b(),epochVoteAccount:dt(),epochCredits:P(us([b(),b(),b()])),commission:b(),lastVote:b(),rootSlot:T(b())}),Nd=Y(I({current:P(io),delinquent:P(io)})),zd=Me([be("processed"),be("confirmed"),be("finalized")]),Kd=I({slot:b(),confirmations:T(b()),err:Yt,confirmationStatus:H(zd)}),Wd=Se(P(T(Kd))),Fd=Y(b()),Ni=I({accountKey:we,writableIndexes:P(b()),readonlyIndexes:P(b())}),gs=I({signatures:P(E()),message:I({accountKeys:P(E()),header:I({numRequiredSignatures:b(),numReadonlySignedAccounts:b(),numReadonlyUnsignedAccounts:b()}),instructions:P(I({accounts:P(b()),data:E(),programIdIndex:b()})),recentBlockhash:E(),addressTableLookups:H(P(Ni))})}),zi=I({pubkey:we,signer:dt(),writable:dt(),source:H(Me([be("transaction"),be("lookupTable")]))}),Ki=I({accountKeys:P(zi),signatures:P(E())}),Wi=I({parsed:hn(),program:E(),programId:we}),Fi=I({accounts:P(we),data:E(),programId:we}),Dd=Me([Fi,Wi]),qd=Me([I({parsed:hn(),program:E(),programId:E()}),I({accounts:P(E()),data:E(),programId:E()})]),Di=Bn(Dd,qd,r=>"accounts"in r?v(r,Fi):v(r,Wi)),qi=I({signatures:P(E()),message:I({accountKeys:P(zi),instructions:P(Di),recentBlockhash:E(),addressTableLookups:H(T(P(Ni)))})}),Yn=I({accountIndex:b(),mint:E(),owner:H(E()),programId:H(E()),uiTokenAmount:Wr}),Hi=I({writable:P(we),readonly:P(we)}),cr=I({err:Yt,fee:b(),innerInstructions:H(T(P(I({index:b(),instructions:P(I({accounts:P(b()),data:E(),programIdIndex:b()}))})))),preBalances:P(b()),postBalances:P(b()),logMessages:H(T(P(E()))),preTokenBalances:H(T(P(Yn))),postTokenBalances:H(T(P(Yn))),loadedAddresses:H(Hi),computeUnitsConsumed:H(b())}),ys=I({err:Yt,fee:b(),innerInstructions:H(T(P(I({index:b(),instructions:P(Di)})))),preBalances:P(b()),postBalances:P(b()),logMessages:H(T(P(E()))),preTokenBalances:H(T(P(Yn))),postTokenBalances:H(T(P(Yn))),loadedAddresses:H(Hi),computeUnitsConsumed:H(b())}),fn=Me([be(0),be("legacy")]),Zt=I({pubkey:E(),lamports:b(),postBalance:T(b()),rewardType:T(E()),commission:H(T(b()))}),Hd=Y(T(I({blockhash:E(),previousBlockhash:E(),parentSlot:b(),transactions:P(I({transaction:gs,meta:T(cr),version:H(fn)})),rewards:H(P(Zt)),blockTime:T(b()),blockHeight:T(b())}))),Md=Y(T(I({blockhash:E(),previousBlockhash:E(),parentSlot:b(),rewards:H(P(Zt)),blockTime:T(b()),blockHeight:T(b())}))),$d=Y(T(I({blockhash:E(),previousBlockhash:E(),parentSlot:b(),transactions:P(I({transaction:Ki,meta:T(cr),version:H(fn)})),rewards:H(P(Zt)),blockTime:T(b()),blockHeight:T(b())}))),Vd=Y(T(I({blockhash:E(),previousBlockhash:E(),parentSlot:b(),transactions:P(I({transaction:qi,meta:T(ys),version:H(fn)})),rewards:H(P(Zt)),blockTime:T(b()),blockHeight:T(b())}))),jd=Y(T(I({blockhash:E(),previousBlockhash:E(),parentSlot:b(),transactions:P(I({transaction:Ki,meta:T(ys),version:H(fn)})),rewards:H(P(Zt)),blockTime:T(b()),blockHeight:T(b())}))),Gd=Y(T(I({blockhash:E(),previousBlockhash:E(),parentSlot:b(),rewards:H(P(Zt)),blockTime:T(b()),blockHeight:T(b())}))),Yd=Y(T(I({blockhash:E(),previousBlockhash:E(),parentSlot:b(),transactions:P(I({transaction:gs,meta:T(cr)})),rewards:H(P(Zt)),blockTime:T(b())}))),ao=Y(T(I({blockhash:E(),previousBlockhash:E(),parentSlot:b(),signatures:P(E()),blockTime:T(b())}))),Pr=Y(T(I({slot:b(),meta:T(cr),blockTime:H(T(b())),transaction:gs,version:H(fn)}))),Un=Y(T(I({slot:b(),transaction:qi,meta:T(ys),blockTime:H(T(b())),version:H(fn)}))),Zd=Se(I({blockhash:E(),feeCalculator:I({lamportsPerSignature:b()})})),Jd=Se(I({blockhash:E(),lastValidBlockHeight:b()})),Xd=Se(dt()),Qd=I({slot:b(),numTransactions:b(),numSlots:b(),samplePeriodSecs:b()}),eh=Y(P(Qd)),th=Se(T(I({feeCalculator:I({lamportsPerSignature:b()})}))),nh=Y(E()),rh=Y(E()),sh=I({err:Yt,logs:P(E()),signature:E()}),oh=I({result:ar(sh),subscription:b()}),ih={"solana-client":"js/1.0.0-maintenance"};class Kh{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const u={};return async l=>{const{commitment:d,config:p}=de(l),f=this._buildArgs([],d,void 0,p),y=to(f);return u[y]=u[y]??(async()=>{try{const g=await this._rpcRequest("getBlockHeight",f),h=v(g,Y(b()));if("error"in h)throw new K(h.error,"failed to get block height information");return h.result}finally{delete u[y]}})(),await u[y]}})();let n,s,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=Ml(e),this._rpcWsEndpoint=n||ql(e),this._rpcClient=od(e,s,o,i,a,c),this._rpcRequest=id(this._rpcClient),this._rpcBatchRequest=ad(this._rpcClient),this._rpcWebSocket=new Kl(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=de(t),o=this._buildArgs([e.toBase58()],n,void 0,s),i=await this._rpcRequest("getBalance",o),a=v(i,Se(b()));if("error"in a)throw new K(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=v(t,Y(T(b())));if("error"in n)throw new K(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=v(e,Y(b()));if("error"in t)throw new K(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=v(e,pd);if("error"in t)throw new K(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=v(n,gd);if("error"in s)throw new K(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),o=v(s,Se(Wr));if("error"in o)throw new K(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),o=v(s,Se(Wr));if("error"in o)throw new K(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:o}=de(n);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,s,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),u=v(c,bd);if("error"in u)throw new K(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);return u.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=v(i,md);if("error"in a)throw new K(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),o=v(s,wd);if("error"in o)throw new K(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),o=v(s,yd);if("error"in o)throw new K(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=de(t),o=this._buildArgs([e.toBase58()],n,"base64",s),i=await this._rpcRequest("getAccountInfo",o),a=v(i,Se(T(xn)));if("error"in a)throw new K(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=de(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",o),a=v(i,Se(T(Dr)));if("error"in a)throw new K(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=de(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=v(a,Se(P(T(Dr))));if("error"in c)throw new K(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=de(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=v(a,Se(P(T(xn))));if("error"in c)throw new K(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:o}=de(t),i=this._buildArgs([e.toBase58()],s,void 0,{...o,epoch:n??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getStakeActivation",i),c=v(a,Y(xd));if("error"in c)throw new K(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=de(t),{encoding:o,...i}=s||{},a=this._buildArgs([e.toBase58()],n,o||"base64",{...i,...i.filters?{filters:so(i.filters)}:null}),c=await this._rpcRequest("getProgramAccounts",a),u=P(kd),l=i.withContext===!0?v(c,Se(u)):v(c,Y(u));if("error"in l)throw new K(l.error,`failed to get accounts owned by program ${e.toBase58()}`);return l.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=de(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",o),a=v(i,Y(P(Id)));if("error"in a)throw new K(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var o;let n;if(typeof e=="string")n=e;else{const i=e;if((o=i.abortSignal)!=null&&o.aborted)return Promise.reject(i.abortSignal.reason);n=i.signature}let s;try{s=Oe.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return se(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,o=!1;const i=new Promise((c,u)=>{try{n=this.onSignature(t,(d,p)=>{n=void 0;const f={context:p,value:d};c({__type:Lt.PROCESSED,response:f})},e);const l=new Promise(d=>{n==null?d():s=this._onSubscriptionStateChange(n,p=>{p==="subscribed"&&d()})});(async()=>{if(await l,o)return;const d=await this.getSignatureStatus(t);if(o||d==null)return;const{context:p,value:f}=d;if(f!=null)if(f!=null&&f.err)u(f.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(f.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(f.confirmationStatus==="processed"||f.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:Lt.PROCESSED,response:{context:p,value:f}})}})()}catch(l){u(l)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let o=!1;const i=new Promise(d=>{const p=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let f=await p();if(!o){for(;f<=n;)if(await Ft(1e3),o||(f=await p(),o))return;d({__type:Lt.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),u=this.getCancellationPromise(t);let l;try{const d=await Promise.race([u,c,i]);if(d.__type===Lt.PROCESSED)l=d.response;else throw new Ei(s)}finally{o=!0,a()}return l}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(f=>{let y=o,g=null;const h=async()=>{try{const{context:k,value:x}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return g=k.slot,x==null?void 0:x.nonce}catch{return y}};(async()=>{if(y=await h(),!a)for(;;){if(o!==y){f({__type:Lt.NONCE_INVALID,slotInWhichNonceDidAdvance:g});return}if(await Ft(2e3),a||(y=await h(),a))return}})()}),{abortConfirmation:u,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),d=this.getCancellationPromise(t);let p;try{const f=await Promise.race([d,l,c]);if(f.__type===Lt.PROCESSED)p=f.response;else{let y;for(;;){const g=await this.getSignatureStatus(i);if(g==null)break;if(g.context.slot<(f.slotInWhichNonceDidAdvance??n)){await Ft(400);continue}y=g;break}if(y!=null&&y.value){const g=e||"finalized",{confirmationStatus:h}=y.value;switch(g){case"processed":case"recent":if(h!=="processed"&&h!=="confirmed"&&h!=="finalized")throw new yn(i);break;case"confirmed":case"single":case"singleGossip":if(h!=="confirmed"&&h!=="finalized")throw new yn(i);break;case"finalized":case"max":case"root":if(h!=="finalized")throw new yn(i);break;default:}p={context:y.context,value:{err:y.value.err}}}else throw new yn(i)}}finally{a=!0,u()}return p}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(c=>{let u=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{u=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:Lt.TIMED_OUT,timeoutMs:u}),u)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,s]);if(c.__type===Lt.PROCESSED)a=c.response;else throw new _i(t,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=v(e,Y(P(Ud)));if("error"in t)throw new K(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=v(n,Nd);if("error"in s)throw new K(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=de(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlot",s),i=v(o,Y(b()));if("error"in i)throw new K(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:n}=de(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlotLeader",s),i=v(o,Y(E()));if("error"in i)throw new K(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),o=v(s,Y(P(we)));if("error"in o)throw new K(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);se(s.length===1);const o=s[0];return{context:n,value:o}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),o=v(s,Wd);if("error"in o)throw new K(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:n}=de(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getTransactionCount",s),i=v(o,Y(b()));if("error"in i)throw new K(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=v(n,cd);if("error"in s)throw new K(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:o}=de(n),i=this._buildArgs([e.map(u=>u.toBase58())],s,void 0,{...o,epoch:t??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getInflationReward",i),c=v(a,jl);if("error"in c)throw new K(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=v(e,ud);if("error"in t)throw new K(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=de(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getEpochInfo",s),i=v(o,dd);if("error"in i)throw new K(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=v(e,hd);if("error"in t)throw new K(t.error,"failed to get epoch schedule");const n=t.result;return new Nl(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=v(e,fd);if("error"in t)throw new K(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=v(s,Fd);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),s=v(n,Zd);if("error"in s)throw new K(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=v(t,eh);if("error"in n)throw new K(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=v(s,th);if("error"in o)throw new K(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=Z(e.serialize()).toString("base64"),s=this._buildArgs([n],t),o=await this._rpcRequest("getFeeForMessage",s),i=v(o,Se(T(b())));if("error"in i)throw new K(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){var i;const t=(i=e==null?void 0:e.lockedWritableAccounts)==null?void 0:i.map(a=>a.toBase58()),n=t!=null&&t.length?[t]:[],s=await this._rpcRequest("getRecentPrioritizationFees",n),o=v(s,ld);if("error"in o)throw new K(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=de(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getLatestBlockhash",s),i=v(o,Jd);if("error"in i)throw new K(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){const{commitment:n,config:s}=de(t),o=this._buildArgs([e],n,void 0,s),i=await this._rpcRequest("isBlockhashValid",o),a=v(i,Xd);if("error"in a)throw new K(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=v(e,Y(td));if("error"in t)throw new K(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=v(e,Y(E()));if("error"in t)throw new K(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=de(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getBlock",o);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=v(i,$d);if("error"in a)throw a.error;return a.result}case"none":{const a=v(i,Md);if("error"in a)throw a.error;return a.result}default:{const a=v(i,Hd);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:u,meta:l,version:d})=>({meta:l,transaction:{...u,message:Rr(d,u.message)},version:d}))}:null}}}catch(a){throw new K(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=de(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getBlock",o);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=v(i,jd);if("error"in a)throw a.error;return a.result}case"none":{const a=v(i,Gd);if("error"in a)throw a.error;return a.result}default:{const a=v(i,Vd);if("error"in a)throw a.error;return a.result}}}catch(a){throw new K(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const s=this._buildArgs([],n,"base64",t),o=await this._rpcRequest("getBlockProduction",s),i=v(o,sd);if("error"in i)throw new K(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:n,config:s}=de(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getTransaction",o),a=v(i,Pr);if("error"in a)throw new K(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Rr(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=de(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getTransaction",o),a=v(i,Un);if("error"in a)throw new K(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=de(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=v(c,Un);if("error"in u)throw new K(u.error,"failed to get transactions");return u.result})}async getTransactions(e,t){const{commitment:n,config:s}=de(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=v(c,Pr);if("error"in u)throw new K(u.error,"failed to get transactions");const l=u.result;return l&&{...l,transaction:{...l.transaction,message:Rr(l.version,l.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",n),o=v(s,Yd);if("error"in o)throw new K(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:u})=>{const l=new ht(c.message);return{meta:u,transaction:{...c,message:l}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:u})=>({meta:u,transaction:ae.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=await this._rpcRequest("getBlocks",s),i=v(o,Y(P(b())));if("error"in i)throw new K(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),o=v(s,ao);if("error"in o)throw new K(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",n),o=v(s,ao);if("error"in o)throw new K(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",n),o=v(s,Pr);if("error"in o)throw new K(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new ht(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:ae.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",n),o=v(s,Un);if("error"in o)throw new K(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const n=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{const a=v(i,Un);if("error"in a)throw new K(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},o=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>i));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=v(o,Ad);if("error"in i)throw new K(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",s),i=v(o,Ed);if("error"in i)throw new K(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=new ro({key:e,state:ro.deserialize(s.data)})),{context:n,value:o}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=fs.fromAccountData(s.data)),{context:n,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=v(n,nh);if("error"in s)throw new K(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await Ft(100);const n=Date.now()-this._blockhashInfo.lastFetch>=Hl;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await Ft(Li/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=de(e),s=this._buildArgs([],t,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",s),i=v(o,Se(b()));if("error"in i)throw new K(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){const g=e.serialize(),h=M.from(g).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const k=t||{};k.encoding="base64","commitment"in k||(k.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(k.innerInstructions=t.innerInstructions);const x=[h,k],w=await this._rpcRequest("simulateTransaction",x),R=v(w,oo);if("error"in R)throw new Error("failed to simulate transaction: "+R.error.message);return R.result}let s;if(e instanceof ae){let y=e;s=new ae,s.feePayer=y.feePayer,s.instructions=e.instructions,s.nonceInfo=y.nonceInfo,s.signatures=y.signatures}else s=ae.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(s.nonceInfo&&o)s.sign(...o);else{let y=this._disableBlockhashCaching;for(;;){const g=await this._blockhashWithExpiryBlockHeight(y);if(s.lastValidBlockHeight=g.lastValidBlockHeight,s.recentBlockhash=g.blockhash,!o)break;if(s.sign(...o),!s.signature)throw new Error("!signature");const h=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(h)&&!this._blockhashInfo.transactionSignatures.includes(h)){this._blockhashInfo.simulatedSignatures.push(h);break}else y=!0}}const i=s._compile(),a=i.serialize(),u=s._serialize(a).toString("base64"),l={encoding:"base64",commitment:this.commitment};if(n){const y=(Array.isArray(n)?n:i.nonProgramIds()).map(g=>g.toBase58());l.accounts={encoding:"base64",addresses:y}}o&&(l.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(l.innerInstructions=t.innerInstructions);const d=[u,l],p=await this._rpcRequest("simulateTransaction",d),f=v(p,oo);if("error"in f){let y;if("data"in f.error&&(y=f.error.data.logs,y&&Array.isArray(y))){const g=`
    `,h=g+y.join(g);console.error(f.error.message,h)}throw new Gn({action:"simulate",signature:"",transactionMessage:f.error.message,logs:y})}return f.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(e,t){const n=Z(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,o=s===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),o&&(n.preflightCommitment=o);const i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=v(a,rh);if("error"in c){let u;throw"data"in c.error&&(u=c.error.data.logs),new Gn({action:s?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:u})}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var s;const n=(s=this._subscriptionsByHash[e])==null?void 0:s.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const o=this._subscriptionStateChangeCallbacksByHash[e];o&&o.forEach(i=>{try{i(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var o;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=(o=this._subscriptionStateChangeCallbacksByHash)[n]||(o[n]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(n,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(console.error(`Received ${a instanceof Error?"":"JSON-RPC "}error calling \`${i}\``,{args:o,error:a}),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=v(e,_d);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=to([e.method,t]),o=this._subscriptionsByHash[s];return o===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const i=this._subscriptionsByHash[s];se(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const{commitment:s,config:o}=de(n),i=this._buildArgs([e.toBase58()],s||this._commitment||"finalized","base64",o);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=v(e,Bd);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const{commitment:o,config:i}=de(n),a=this._buildArgs([e.toBase58()],o||this._commitment||"finalized","base64",i||(s?{filters:so(s)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=v(e,oh);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=v(e,Pd);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=v(e,Ld);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const o=t||this._commitment;if(o||n||s){let i={};n&&(i.encoding=n),o&&(i.commitment=o),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=v(e,Cd);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}onSignatureWithOptions(e,t,n){const{commitment:s,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],s,void 0,o),a=this._makeSubscription({callback:(c,u)=>{t(c,u);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=v(e,Od);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class bn{constructor(e){this._keypair=void 0,this._keypair=e??Ys()}static generate(){return new bn(Ys())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const s=e.slice(0,32),o=$n(s);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new bn({publicKey:n,secretKey:e})}static fromSeed(e){const t=$n(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new bn({publicKey:t,secretKey:n})}get publicKey(){return new B(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const Ct=Object.freeze({CreateLookupTable:{index:0,layout:U([O("instruction"),on("recentSlot"),ne("bumpSeed")])},FreezeLookupTable:{index:1,layout:U([O("instruction")])},ExtendLookupTable:{index:2,layout:U([O("instruction"),on(),Ne(X(),Nt(O(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:U([O("instruction")])},CloseLookupTable:{index:4,layout:U([O("instruction")])}});class Wh{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=O("instruction").decode(e.data);let s;for(const[o,i]of Object.entries(Ct))if(i.index==n){s=o;break}if(!s)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return s}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=ie(Ct.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=ie(Ct.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(n=>new B(n))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Mi.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class Mi{constructor(){}static createLookupTable(e){const[t,n]=B.findProgramAddressSync([e.authority.toBuffer(),li(BigInt(e.recentSlot),8)],this.programId),s=Ct.CreateLookupTable,o=te(s,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Ue.programId,isSigner:!1,isWritable:!1}];return[new he({programId:this.programId,keys:i,data:o}),t]}static freezeLookupTable(e){const t=Ct.FreezeLookupTable,n=te(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new he({programId:this.programId,keys:s,data:n})}static extendLookupTable(e){const t=Ct.ExtendLookupTable,n=te(t,{addresses:e.addresses.map(o=>o.toBytes())}),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&s.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Ue.programId,isSigner:!1,isWritable:!1}),new he({programId:this.programId,keys:s,data:n})}static deactivateLookupTable(e){const t=Ct.DeactivateLookupTable,n=te(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new he({programId:this.programId,keys:s,data:n})}static closeLookupTable(e){const t=Ct.CloseLookupTable,n=te(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new he({programId:this.programId,keys:s,data:n})}}Mi.programId=new B("AddressLookupTab1e1111111111111111111111111");class Fh{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=ne("instruction").decode(e.data);let s;for(const[o,i]of Object.entries(It))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return s}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:n}=ie(It.RequestUnits,e.data);return{units:t,additionalFee:n}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=ie(It.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=ie(It.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=ie(It.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals($i.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const It=Object.freeze({RequestUnits:{index:0,layout:U([ne("instruction"),O("units"),O("additionalFee")])},RequestHeapFrame:{index:1,layout:U([ne("instruction"),O("bytes")])},SetComputeUnitLimit:{index:2,layout:U([ne("instruction"),O("units")])},SetComputeUnitPrice:{index:3,layout:U([ne("instruction"),on("microLamports")])}});class $i{constructor(){}static requestUnits(e){const t=It.RequestUnits,n=te(t,e);return new he({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){const t=It.RequestHeapFrame,n=te(t,e);return new he({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){const t=It.SetComputeUnitLimit,n=te(t,e);return new he({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){const t=It.SetComputeUnitPrice,n=te(t,{microLamports:BigInt(e.microLamports)});return new he({keys:[],programId:this.programId,data:n})}}$i.programId=new B("ComputeBudget111111111111111111111111111111");const co=64,uo=32,lo=64,ho=U([ne("numSignatures"),ne("padding"),Qe("signatureOffset"),Qe("signatureInstructionIndex"),Qe("publicKeyOffset"),Qe("publicKeyInstructionIndex"),Qe("messageDataOffset"),Qe("messageDataSize"),Qe("messageInstructionIndex")]);class bs{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:s,instructionIndex:o}=e;se(t.length===uo,`Public Key must be ${uo} bytes but received ${t.length} bytes`),se(s.length===lo,`Signature must be ${lo} bytes but received ${s.length} bytes`);const i=ho.span,a=i+t.length,c=a+s.length,u=1,l=M.alloc(c+n.length),d=o??65535;return ho.encode({numSignatures:u,padding:0,signatureOffset:a,signatureInstructionIndex:d,publicKeyOffset:i,publicKeyInstructionIndex:d,messageDataOffset:c,messageDataSize:n.length,messageInstructionIndex:d},l),l.fill(t,i),l.fill(s,a),l.fill(n,c),new he({keys:[],programId:bs.programId,data:l})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:s}=e;se(t.length===co,`Private key must be ${co} bytes but received ${t.length} bytes`);try{const o=bn.fromSecretKey(t),i=o.publicKey.toBytes(),a=ds(n,o.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:a,instructionIndex:s})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}}bs.programId=new B("Ed25519SigVerify111111111111111111111111111");const ah=(r,e)=>{const t=or.sign(r,e);return[t.toCompactRawBytes(),t.recovery]};or.utils.isValidPrivateKey;const ch=or.getPublicKey,fo=32,Tr=20,po=64,uh=11,Lr=U([ne("numSignatures"),Qe("signatureOffset"),ne("signatureInstructionIndex"),Qe("ethAddressOffset"),ne("ethAddressInstructionIndex"),Qe("messageDataOffset"),Qe("messageDataSize"),ne("messageInstructionIndex"),pe(20,"ethAddress"),pe(64,"signature"),ne("recoveryId")]);class mn{constructor(){}static publicKeyToEthAddress(e){se(e.length===po,`Public key must be ${po} bytes but received ${e.length} bytes`);try{return M.from(Ms(Z(e))).slice(-Tr)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:s,recoveryId:o,instructionIndex:i}=e;return mn.createInstructionWithEthAddress({ethAddress:mn.publicKeyToEthAddress(t),message:n,signature:s,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:n,signature:s,recoveryId:o,instructionIndex:i=0}=e;let a;typeof t=="string"?t.startsWith("0x")?a=M.from(t.substr(2),"hex"):a=M.from(t,"hex"):a=t,se(a.length===Tr,`Address must be ${Tr} bytes but received ${a.length} bytes`);const c=1+uh,u=c,l=c+a.length,d=l+s.length+1,p=1,f=M.alloc(Lr.span+n.length);return Lr.encode({numSignatures:p,signatureOffset:l,signatureInstructionIndex:i,ethAddressOffset:u,ethAddressInstructionIndex:i,messageDataOffset:d,messageDataSize:n.length,messageInstructionIndex:i,signature:Z(s),ethAddress:Z(a),recoveryId:o},f),f.fill(Z(n),Lr.span),new he({keys:[],programId:mn.programId,data:f})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:s}=e;se(t.length===fo,`Private key must be ${fo} bytes but received ${t.length} bytes`);try{const o=Z(t),i=ch(o,!1).slice(1),a=M.from(Ms(Z(n))),[c,u]=ah(a,o);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:c,recoveryId:u,instructionIndex:s})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}}mn.programId=new B("KeccakSecp256k11111111111111111111111111111");var Vi;const lh=new B("StakeConfig11111111111111111111111111111111");class dh{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class ur{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}Vi=ur;ur.default=new Vi(0,0,B.default);class Dh{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=O("instruction").decode(e.data);let s;for(const[o,i]of Object.entries(Le))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a StakeInstruction");return s}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:n}=ie(Le.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new dh(new B(t.staker),new B(t.withdrawer)),lockup:new ur(n.unixTimestamp,n.epoch,new B(n.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),ie(Le.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:n}=ie(Le.Authorize,e.data),s={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new B(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(s.custodianPubkey=e.keys[3].pubkey),s}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:n,authoritySeed:s,authorityOwner:o}=ie(Le.AuthorizeWithSeed,e.data),i={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:s,authorityOwner:new B(o),newAuthorizedPubkey:new B(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=ie(Le.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ie(Le.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=ie(Le.Withdraw,e.data),n={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(n.custodianPubkey=e.keys[5].pubkey),n}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ie(Le.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(ms.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Le=Object.freeze({Initialize:{index:0,layout:U([O("instruction"),kl(),Sl()])},Authorize:{index:1,layout:U([O("instruction"),X("newAuthorized"),O("stakeAuthorizationType")])},Delegate:{index:2,layout:U([O("instruction")])},Split:{index:3,layout:U([O("instruction"),Ze("lamports")])},Withdraw:{index:4,layout:U([O("instruction"),Ze("lamports")])},Deactivate:{index:5,layout:U([O("instruction")])},Merge:{index:7,layout:U([O("instruction")])},AuthorizeWithSeed:{index:8,layout:U([O("instruction"),X("newAuthorized"),O("stakeAuthorizationType"),Dt("authoritySeed"),X("authorityOwner")])}}),qh=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class ms{constructor(){}static initialize(e){const{stakePubkey:t,authorized:n,lockup:s}=e,o=s||ur.default,i=Le.Initialize,a=te(i,{authorized:{staker:Z(n.staker.toBuffer()),withdrawer:Z(n.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:Z(o.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:In,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new he(c)}static createAccountWithSeed(e){const t=new ae;t.add(Ue.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:s,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:s,lockup:o}))}static createAccount(e){const t=new ae;t.add(Ue.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:s,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:s,lockup:o}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:n,votePubkey:s}=e,o=Le.Delegate,i=te(o);return new ae().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:wt,isSigner:!1,isWritable:!1},{pubkey:_r,isSigner:!1,isWritable:!1},{pubkey:lh,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){const{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:s,stakeAuthorizationType:o,custodianPubkey:i}=e,a=Le.Authorize,c=te(a,{newAuthorized:Z(s.toBuffer()),stakeAuthorizationType:o.index}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:wt,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&u.push({pubkey:i,isSigner:!0,isWritable:!1}),new ae().add({keys:u,programId:this.programId,data:c})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:n,authoritySeed:s,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,u=Le.AuthorizeWithSeed,l=te(u,{newAuthorized:Z(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:s,authorityOwner:Z(o.toBuffer())}),d=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:wt,isSigner:!1,isWritable:!1}];return c&&d.push({pubkey:c,isSigner:!0,isWritable:!1}),new ae().add({keys:d,programId:this.programId,data:l})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:s,lamports:o}=e,i=Le.Split,a=te(i,{lamports:o});return new he({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){const n=new ae;return n.add(Ue.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:n,authorizedPubkey:s,splitStakePubkey:o,basePubkey:i,seed:a,lamports:c}=e,u=new ae;return u.add(Ue.allocate({accountPubkey:o,basePubkey:i,seed:a,space:this.space,programId:this.programId})),t&&t>0&&u.add(Ue.transfer({fromPubkey:e.authorizedPubkey,toPubkey:o,lamports:t})),u.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:s,splitStakePubkey:o,lamports:c}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:s}=e,o=Le.Merge,i=te(o);return new ae().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:wt,isSigner:!1,isWritable:!1},{pubkey:_r,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:n,toPubkey:s,lamports:o,custodianPubkey:i}=e,a=Le.Withdraw,c=te(a,{lamports:o}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:wt,isSigner:!1,isWritable:!1},{pubkey:_r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&u.push({pubkey:i,isSigner:!0,isWritable:!1}),new ae().add({keys:u,programId:this.programId,data:c})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:n}=e,s=Le.Deactivate,o=te(s);return new ae().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:wt,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}}ms.programId=new B("Stake11111111111111111111111111111111111111");ms.space=200;class hh{constructor(e,t,n,s){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=n,this.commission=s}}class Hh{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=O("instruction").decode(e.data);let s;for(const[o,i]of Object.entries(ut))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a VoteInstruction");return s}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=ie(ut.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new hh(new B(t.nodePubkey),new B(t.authorizedVoter),new B(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:n}=ie(ut.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new B(t),voteAuthorizationType:{index:n}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:n,newAuthorized:s,voteAuthorizationType:o}}=ie(ut.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new B(t),currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:new B(s),voteAuthorizationType:{index:o},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=ie(ut.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Rn.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const ut=Object.freeze({InitializeAccount:{index:0,layout:U([O("instruction"),Il()])},Authorize:{index:1,layout:U([O("instruction"),X("newAuthorized"),O("voteAuthorizationType")])},Withdraw:{index:3,layout:U([O("instruction"),Ze("lamports")])},UpdateValidatorIdentity:{index:4,layout:U([O("instruction")])},AuthorizeWithSeed:{index:10,layout:U([O("instruction"),xl()])}}),Mh=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Rn{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:n,voteInit:s}=e,o=ut.InitializeAccount,i=te(o,{voteInit:{nodePubkey:Z(s.nodePubkey.toBuffer()),authorizedVoter:Z(s.authorizedVoter.toBuffer()),authorizedWithdrawer:Z(s.authorizedWithdrawer.toBuffer()),commission:s.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:In,isSigner:!1,isWritable:!1},{pubkey:wt,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new he(a)}static createAccount(e){const t=new ae;return t.add(Ue.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:s,voteAuthorizationType:o}=e,i=ut.Authorize,a=te(i,{newAuthorized:Z(s.toBuffer()),voteAuthorizationType:o.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:wt,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new ae().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:s,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:a}=e,c=ut.AuthorizeWithSeed,u=te(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:Z(n.toBuffer()),currentAuthorityDerivedKeySeed:s,newAuthorized:Z(o.toBuffer()),voteAuthorizationType:i.index}}),l=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:wt,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new ae().add({keys:l,programId:this.programId,data:u})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:s,toPubkey:o}=e,i=ut.Withdraw,a=te(i,{lamports:s}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new ae().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return Rn.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,nodePubkey:s}=e,o=ut.UpdateValidatorIdentity,i=te(o),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new ae().add({keys:a,programId:this.programId,data:i})}}Rn.programId=new B("Vote111111111111111111111111111111111111111");Rn.space=3762;const fh=new B("Va1idator1nfo111111111111111111111111111111"),ph=I({name:E(),website:H(E()),details:H(E()),iconUrl:H(E()),keybaseUsername:H(E())});class ji{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(je(t)!==2)return null;const s=[];for(let o=0;o<2;o++){const i=new B(Ge(t,0,At)),a=ct(t)===1;s.push({publicKey:i,isSigner:a})}if(s[0].publicKey.equals(fh)&&s[1].isSigner){const o=Dt().decode(M.from(t)),i=JSON.parse(o);return di(i,ph),new ji(s[1].publicKey,i)}return null}}const $h=new B("Vote111111111111111111111111111111111111111"),gh=U([X("nodePubkey"),X("authorizedWithdrawer"),ne("commission"),Te(),Ne(U([Te("slot"),O("confirmationCount")]),Nt(O(),-8),"votes"),ne("rootSlotValid"),Te("rootSlot"),Te(),Ne(U([Te("epoch"),X("authorizedVoter")]),Nt(O(),-8),"authorizedVoters"),U([Ne(U([X("authorizedPubkey"),Te("epochOfLastAuthorizedSwitch"),Te("targetEpoch")]),32,"buf"),Te("idx"),ne("isEmpty")],"priorVoters"),Te(),Ne(U([Te("epoch"),Te("credits"),Te("prevCredits")]),Nt(O(),-8),"epochCredits"),U([Te("slot"),Te("timestamp")],"lastTimestamp")]);class Gi{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const n=gh.decode(Z(e),4);let s=n.rootSlot;return n.rootSlotValid||(s=null),new Gi({nodePubkey:new B(n.nodePubkey),authorizedWithdrawer:new B(n.authorizedWithdrawer),commission:n.commission,votes:n.votes,rootSlot:s,authorizedVoters:n.authorizedVoters.map(yh),priorVoters:bh(n.priorVoters),epochCredits:n.epochCredits,lastTimestamp:n.lastTimestamp})}}function yh({authorizedVoter:r,epoch:e}){return{epoch:e,authorizedVoter:new B(r)}}function go({authorizedPubkey:r,epochOfLastAuthorizedSwitch:e,targetEpoch:t}){return{authorizedPubkey:new B(r),epochOfLastAuthorizedSwitch:e,targetEpoch:t}}function bh({buf:r,idx:e,isEmpty:t}){return t?[]:[...r.slice(e+1).map(go),...r.slice(0,e).map(go)]}const yo={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function Vh(r,e){const t=e===!1?"http":"https";if(!r)return yo[t].devnet;const n=yo[t][r];if(!n)throw new Error(`Unknown ${t} cluster: ${r}`);return n}async function jh(r,e,t,n){let s,o;t&&Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")||t&&Object.prototype.hasOwnProperty.call(t,"nonceValue")?(s=t,o=n):o=t;const i=o&&{skipPreflight:o.skipPreflight,preflightCommitment:o.preflightCommitment||o.commitment,minContextSlot:o.minContextSlot},a=await r.sendRawTransaction(e,i),c=o&&o.commitment,l=(await(s?r.confirmTransaction(s,c):r.confirmTransaction(a,c))).value;if(l.err)throw a!=null?new Gn({action:i!=null&&i.skipPreflight?"send":"simulate",signature:a,transactionMessage:`Status: (${JSON.stringify(l)})`}):new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`);return a}const Gh=1e9;export{vh as Account,ro as AddressLookupTableAccount,Wh as AddressLookupTableInstruction,Mi as AddressLookupTableProgram,dh as Authorized,Hl as BLOCKHASH_CACHE_TIMEOUT_MS,Bh as BPF_LOADER_DEPRECATED_PROGRAM_ID,Nh as BPF_LOADER_PROGRAM_ID,zh as BpfLoader,It as COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,Fh as ComputeBudgetInstruction,$i as ComputeBudgetProgram,Kh as Connection,bs as Ed25519Program,_h as Enum,Nl as EpochSchedule,Bl as FeeCalculatorLayout,bn as Keypair,Gh as LAMPORTS_PER_SOL,Ct as LOOKUP_TABLE_INSTRUCTION_LAYOUTS,an as Loader,ur as Lockup,bl as MAX_SEED_LENGTH,ht as Message,jn as MessageAccountKeys,sn as MessageV0,Qs as NONCE_ACCOUNT_LENGTH,fs as NonceAccount,Ht as PACKET_DATA_SIZE,At as PUBLIC_KEY_LENGTH,B as PublicKey,Vn as SIGNATURE_LENGTH_IN_BYTES,Nn as SOLANA_SCHEMA,lh as STAKE_CONFIG_ID,Le as STAKE_INSTRUCTION_LAYOUTS,fe as SYSTEM_INSTRUCTION_LAYOUTS,wt as SYSVAR_CLOCK_PUBKEY,Rh as SYSVAR_EPOCH_SCHEDULE_PUBKEY,Ph as SYSVAR_INSTRUCTIONS_PUBKEY,Er as SYSVAR_RECENT_BLOCKHASHES_PUBKEY,In as SYSVAR_RENT_PUBKEY,Th as SYSVAR_REWARDS_PUBKEY,Lh as SYSVAR_SLOT_HASHES_PUBKEY,Ch as SYSVAR_SLOT_HISTORY_PUBKEY,_r as SYSVAR_STAKE_HISTORY_PUBKEY,mn as Secp256k1Program,Gn as SendTransactionError,K as SolanaJSONRPCError,Oh as SolanaJSONRPCErrorCode,qh as StakeAuthorizationLayout,Dh as StakeInstruction,ms as StakeProgram,xi as Struct,Uh as SystemInstruction,Ue as SystemProgram,ae as Transaction,Ei as TransactionExpiredBlockheightExceededError,yn as TransactionExpiredNonceInvalidError,_i as TransactionExpiredTimeoutError,he as TransactionInstruction,Pi as TransactionMessage,Lt as TransactionStatus,fh as VALIDATOR_INFO_KEY,hs as VERSION_PREFIX_MASK,$h as VOTE_PROGRAM_ID,ji as ValidatorInfo,Ri as VersionedMessage,Ti as VersionedTransaction,Gi as VoteAccount,Mh as VoteAuthorizationLayout,hh as VoteInit,Hh as VoteInstruction,Rn as VoteProgram,Vh as clusterApiUrl,jh as sendAndConfirmRawTransaction,Xs as sendAndConfirmTransaction};
